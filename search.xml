<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[To Be a Better Man.]]></title>
    <url>%2F2019%2F05%2F13%2FTo_Be_a_Better_Man%2F</url>
    <content type="text"><![CDATA[TODO 如果你希望成为一个优秀的人？ 请你远离【负能量】的人，因为他们面对困难只会喋喋不休的抱怨； 请你远离【不自律】的人，因为平庸的人往往都不自律，而不自律很容易传染； 请你远离【不思进取】的人，因为他们根本没有向上的想法。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《忽而今夏》]]></title>
    <url>%2F2019%2F05%2F09%2Finformal_essay_%E5%BF%BD%E8%80%8C%E4%BB%8A%E5%A4%8F%2F</url>
    <content type="text"><![CDATA[《忽而今夏》 作者：明前雨后 简介：主要讲述“章远”和“何洛”从学校到社会，超过十年的爱情故事。 内容： 这里有许多我们熟悉的画面，纯净得让人嫉妒的青春。在我们最意气风发的青春年华，遇见那个最合适的你！ 在简短少年时代，与她有个不一样的夏天。在追寻的路上，朋友的陪伴，让自己都不相信能坚持到最后的自己。 “你说你搭上半条命都考不上，你真的做到了吗？”（真的坚持了吗？） 在自己青春的路上，拼了命一样努力为目标而奋斗！（努力做到了，别人认为她完全不可能做到的事情）。忽然感觉自己的青春都活到了dog身上，一直糊糊涂涂。前半生就这么迷迷糊糊的过去了…… “The best preparation for tomorrow, is doing your best today.”（做今天最好的自己！） 人。不能总这么简简单单的过，总得为了自己的目标而坚持不懈，证明自己也曾年轻过、疯狂过。平凡的我们至少有努力的资格！ 错的只是那些自以为是的一辈子… 总有一天，我们会成为那个连我们都喜欢的自己！ “想清楚自己想干什么？还有能干什么？”（找到自己的方向!） 这个年纪的我们，总得为了某个心疼的她或他而改变，总得让身边的对自己放心。这样多年后的自己，才不会留下任何遗憾！ “Knowledge is power.” 小傻瓜！青春的尾巴遇见你，真巧！余生有你，真好！ 1234567891011121314151617愿望：小时候，梦想成为一个画家；再大一些的时候，梦想成为一个数学家；后来，梦想成为一个梦想；梦想始终是梦想生活才更有动力！终有一天，和她一起去追梦！ 123456789101112梦：在世界的另一边。有个自己的小农场，一间小农舍。每天，日出而作，日落而息！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2019%2F05%2F08%2FMarkDown%2F</url>
    <content type="text"><![CDATA[语法教程：http://www.markdown.cn 链接：![图片描述](图片地址/本地地址)&quot;(空格) 鼠标悬停显示文字(可选)&quot; PS: MD语法可与HTML标签共用； 即：&lt;img src=&quot;http://...&quot; width = &quot;100&quot; height = &quot;100&quot; div align=right /&gt; 邮箱：&lt;邮箱地址&gt;e-mail: &#x74;&#x72;&#121;&#x62;&#115;&#116;&#64;&#x79;&#101;&#97;&#x68;&#x2e;&#x6e;&#101;&#116; 基本常用用法加粗：**Strong** _斜体_：* Emphasize* —下划线—： ---下划线---or&lt;u&gt;下划线&lt;/u&gt; 加粗斜体：***Strong &amp; Emphasize*** 删除线：~~删除线~~ 分割线：***或---或___ 选中标记：&lt;mark&gt;标记&lt;/mark&gt; 转义字符\：So A\*maz\*ing So A*maz*ing 2的n+1次方：2&lt;sup&gt;n&lt;/sup&gt; 2\^(n+1) = 2(n+1) 目录 &amp; 代码块 1 * 1 2 * 2 1. [x] * [x] * [x] 2. [ ] 1$ coding 表格主要使用：|列，-行，:对齐；（PS：最左边和最右边|只是为了美观，: 作为左右对齐的标志；） 单表格1234First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐+多表格12345| Left Aligned | Center Aligned | Right Aligned ||:------------- |:---------------:| -------------:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 复杂表格： 12345678910Option name | Markup | Result if enabled |--------------------|------------------|-----------------------|Intra-word emphasis | So A\*maz\*ing | So A&lt;em&gt;maz&lt;/em&gt;ing |Strikethrough | \~~Much wow\~~ | &lt;del&gt;Much wow&lt;/del&gt; |Underline [^under] | \_So doge\_ | &lt;u&gt;So doge&lt;/u&gt; |Quote [^quote] | \&quot;Such editor\&quot; | &lt;q&gt;Such editor&lt;/q&gt; |Highlight | \==So good\== | &lt;mark&gt;So good&lt;/mark&gt; |Superscript | hoge\^(fuga) | hoge&lt;sup&gt;fuga&lt;/sup&gt; |Autolink | http://t.co | &lt;http://t.co&gt; |Footnotes | [\^4] and [\^4]: | [^4] and footnote 4 | Option name Markup Result if enabled Intra-word emphasis So A*maz*ing So Amazing Strikethrough ~~Much wow~~ Much wow Underline [^under] _So doge_ So doge Quote [^quote] \”Such editor\” Such editor Highlight \==So good\== So good Superscript hoge\^(fuga) hogefuga Autolink http://t.co http://t.co Footnotes [\^4] and [\^4]: [^4] and footnote 4 其他用法12345---title: &quot;title&quot;tag: &quot;md&quot;date: 2019-5-8--- “x”代表已经选中， “ ”代表未选中。12341. [x] I can render checkbox list syntax * [ ] I support nesting * [x] I support ordered *and* unordered lists2. [ ] I don&apos;t support clicking checkboxes directly in the html window I can render checkbox list syntax I support nesting I support ordered and unordered lists I don’t support clicking checkboxes directly in the html window 博客地址：https://www.cnblogs.com/SpongeBob-GitHub/]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析iOS应用“追书神器”]]></title>
    <url>%2F2019%2F05%2F06%2Fzhuishushenqi-analyze%2F</url>
    <content type="text"><![CDATA[&gt; 逆向分析应用 UIView的层级结构 （Reveal） 控制器的层级结构（Cycript） API网络接口（Charles） 代码&amp;框架猜想（class-dump、MachOView等） 12345PS:准备条件1. 已越狱的手机设备2. 对逆向需要的那些工具已经准备好（百度&amp;Google很好实现）3. 通过PP助手等，下载“追书神器”旧版本4. 通过iFunBox将ipa文件下载到电脑，找到Mach-O文件 一：class-dump的初步分析头文件 常用格式： class-dump -H Mach-O文件路径 -o 头文件存放目录 1$ class-dump -H ~/Desktop/iOSRE/mach-o/YouShaQi -o ~/Desktop/iOSRE/header/zhuishushenqi 将zhuishushenqi文件夹通过sublime打开，就可以通过.h文件简单分析里面所用到的框架&amp;方法]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向iOS应用的思路]]></title>
    <url>%2F2019%2F05%2F05%2FiOSRE%2F</url>
    <content type="text"><![CDATA[1.界面分析 [Cycript、Reveal]2.代码分析 [MachOView、class-dump、Hopper Disassembler、ida等]3.动态调试 [对运行中的APP进行代码调试(debugserver、LLDB)]4.代码编写 [注入代码到APP中 必要时还可能需要重新签名、打包ipa] PS: Reveal-&gt;识别 UIView 的层级结构 1. 去下载Reveal4.0以上版本（支持USB调试），并破解（网上有教程） 2. 调试环境配置 2.1 软件源：http://apt.so/codermjlee 2.2 安装完Reveal Loader后，打开手机【设置】，找到Reveal-&gt;Enabled Applications-&gt;选择需要调试的APP 2.3 找到Mac的Reveal中的RevealServer文件，并覆盖iPhone中的/Library/RHRevealLoader/RevealServer文件 2.3.1 Reveal导航栏中Help -&gt; Show Reveal Library in Finder -&gt; iOS Library 2.3.2 重启手机：reboot 3.0 这下打开手机&amp;Reveal就可以实时看到APP的结构 PS：Cycript-&gt;识别 控制器 的层级结构推荐Mj的一个开源库mjcript ting是应用的进程名 1~ root# cycript -p ting 进入cy环境（cmd+r清屏==clear，） 1234cy# @import mjcript&#123;&#125;cy# MJChildVcs(MJRootVc())&#123;&#125;]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods建立私有仓库]]></title>
    <url>%2F2018%2F03%2F18%2FREVIEW%2FCocoaPods%E5%BB%BA%E7%AB%8B%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[简介 CocoaPods是iOS，Mac下优秀的第三方包管理工具，类似于java的maven，给我们项目管理带来了极大的方便。 ［个人或公司在开发过程中，会积累很多可以复用的代码包，有些我们不想开源，又想像开源库一样在CocoaPods中管理它们，那么通过私有仓库来管理就很必要。］ 对于CocoaPods还不太熟悉的，建议参考一下唐巧的博客或者直接到CocoaPods的官网看看：https://cocoapods.org/ CocoaPods默认只能管理基于git管理的代码，如果要使用svn或者mercurial管理代码，则需要安装一些插件 1.创建代码仓库 将自己写的代码推送到git服务器。如果代码可以开源的话，可以用github来托管。参考我们所开源的代码 2.给稳定的代码打上版本tag，一般以版本号作为tag名 1$ git tag -a 将tag推送到git服务器 1$ git push --tags 这里一般是类似1.0.2的版本号。版本号的规范参考这里 3.创建spec文件 1$ pod spec create 会在当前目录创建.podspec文件，创建的文件是个完整的配置模板，根据字面意思以及注释，大体上都能弄明白。不清楚的地方可以到https://guides.cocoapods.org/making/specs-and-specs-repo.html看看，github上也有很多开源代码可以参考。 4.验证spec文件有效性 1$ pod spec lint .podspec 根据输出提示修改你的spec文件或者代码，直到能pass. 5.创建spec repository（spec 仓库） 除了上面创建的代码仓库，还需要创建一个spec仓库，存放spec，目录结构应该遵照以下的规范： 123456789[plain] view plaincopy├── Specs └── [SPEC_NAME] └── [VERSION] └── [SPEC_NAME].podspec 例： 1234567891011121314151617181920212223242526272829├─Specs ├──QueryKit/ ├── 0.8.0 │ └── QueryKit.podspec ├── 0.8.1 │ └── QueryKit.podspec ├── 0.8.2 │ └── QueryKit.podspec └── 0.8.3 └── QueryKit.podspec URITemplate ├── 1.0.0 │ └── URITemplate.podspec └── 1.0.1 └── URITemplate.podspec 这里的版本号要和代码仓库里的tag一一对应。 将其推送到git服务器，参考我们开源的代码 6.添加私有repo到CocoaPods中 1234$ pod repo add REPO_NAME SOURCE_URL``` * 7.验证私有repo安装无误： $ cd ~/.cocoapods/repos/REPO_NAME $ pod repo lint .12后面如果还要往REPO_NAME里添加新包，只需运行下面命令: $ pod repo push REPO_NAME SPEC_NAME.podspec12如要删除私有repo： $ pod repo remove [name]12* 8.添加包到工程的Podfile中如下： source ‘https://github.com/agdsdl/Specs.git&#39; source ‘https://github.com/CocoaPods/Specs.git&#39; platform :ios, “7.0” target “XXX” do pod ‘DLSlideView’,’~&gt;0.8.1’ end1234567* 9. That&apos;s it! 接下来测试运行： 到工程目录下运行 $ pod update` 依赖包更新完毕后，打开workspace文件，点击Go！ 一些坑: 1、很容易把spec repository和代码repository弄混，我一开始就在这里挂起了好久。代码repository是代码仓库，我们把包代码上传到这个仓库。 2、spec repository是配置仓库，所有的配置按照包名、版本号分门别类的存放在这个仓库。这个仓库只用来存放spec文件，不存放代码。、 3、spec repository可以放在本地，不用git服务器，但是貌似必须用git init初始化这个目录。 详细的一些东西可以看这：https://github.com/CocoaPods/CocoaPods/issues/3041 PS：1到8步都只需在本机执行一次，团队里的其他人只需更新Podfile就可以直接使用私有仓库了。]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache & WebDav（二）]]></title>
    <url>%2F2017%2F08%2F24%2FREVIEW%2FApache_WebDav_%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[WebDav配置 &amp; put脚本编辑！WebDav 配置 修改了两个配置文件 创建web访问用户的用户名和口令 创建了两个目录，并且设置了管理权限 12345# 切换目录$ cd /etc/apache2$ sudo vim httpd.conf 12345# 查找httpd-dav.conf/httpd-dav.conf&quot;删除行首#&quot; 123# 将光标定位到行首0 123# 删除行首的注释x 1234567# 打开这三行LoadModule dav_module libexec/apache2/mod_dav.soLoadModule dav_fs_module libexec/apache2/mod_dav_fs.soLoadModule auth_digest_module libexec/apache2/mod_auth_digest.so 123# 保存退出:wq 12345# 切换目录$ cd /etc/apache2/extra``` 备份文件（只要备份一次就行）$ sudo cp httpd-dav.conf httpd-dav.conf.bak1 编辑配置文件$ sudo vim httpd-dav.conf “将Digest修改为Basic”1 查找Digest/Digest1 进入编辑模式i 1234```# 返回到命令行模式ESC 123# 保存退出:wq 123# 切换目录，可以使用鼠标拖拽的方式$ cd 保存put脚本的目录 12345678910111213# 以管理员权限运行put配置脚本$ sudo ./put``` 设置两次密码: 123456 ## put脚本编辑--- 创建put脚本$ vi put 12* 1、输入脚本内容！ 1 # 切换目录 2 echo “切换至/usr目录” 3 cd /usr 4 # 设置用户admin的密码 5 echo “设置admin的密码” 6 htpasswd -c /usr/user.passwd admin 7 # 设置密码文件的访问群组 8 echo “正在创建相关目录并修改访问权限…” 9 chgrp www /usr/user.passwd10 # 建立var文件夹，保存DavLockDB相关文件11 mkdir -p /usr/var12 # 修改var文件夹用户群组13 chown -R www:www /usr/var14 # 建立上传文件夹：uploads15 mkdir -p /usr/uploads16 # 修改uploads文件夹用户群组17 chown -R www:www /usr/uploads18 echo “修改完毕，请确认…”19 ls -lG20 echo “重新启动Apache服务器”21 # 重新启动Apache 22 apachectl -k restart12* 2、保存并退出 $ :x “退出编辑模式后、用：x12 * 3、修改权限 $ chmod 744 put` ［ 每日一句 ］ “ Many of the improvements I introduced when developing C simply looked like a good thing to do. “ – Dennis Ritchie ［ 每天一首英文歌 ］ “ My Bloody Valentine “ – Tata Young]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache & WebDav（一）]]></title>
    <url>%2F2017%2F08%2F23%2FREVIEW%2FApache_WebDav_%E4%B8%80%2F</url>
    <content type="text"><![CDATA[简单Apache服务器的搭建！ 用于文件de上传、下载、修改、删除！ Apache 1.使用最广的 Web 服务器、支持各种脚本(PHP)的执行 2.Mac自带，只需要修改几个配置就可以，简单，快捷 3.有些特殊的服务器功能，Apache都能很好的支持 例如：HTTP PUT/DELETE 操作，知识补充涉及的 HTTPS 服务 WebDav 基于 http 协议的 “文件”服务器 实现文件的上传／下载／修改／删除 FTP 文件传输协议，基于 FTP 的一个文件管理服务器 可以做文件的上传／下载／修改／删除 以上三种服务器，只要 ip 地址能够访问，无论在任何位置，都能够使用！ 关于 WebDav 的权限问题 授权信息的格式 BASIC (用户名:口令)base64 安全性并不高，密码很容易被拦截和破解！ 应用场景：开发企业级的管理系统，可以用 WebDav 搭建一个内部的文件管理服务器，只是在公司内网使用！ Apache 配置： 1、Finder中，当前用户下(/Users/xxx(用户名)/Sites)，创建一个“Sites”文件夹； 1$ mkdir /Users/xxxx/Sites 2、修改配置文件的两个“路径”； 123# 切换目录$ cd /etc/apache2 123# 备份$ sudo cp httpd.conf httpd.conf.bak 123# 编辑$ sudo vi httpd.conf 123# 查找DocumentRoot$ : 修改路径为刚才新建文件夹路径(/Users/xxx(用户名)/Sites) 123# 查找“Options FollowSymLinks Multiviews”，添加一个单词“Indexes”$ : “Options Indexes FollowSymLinks Multiviews” 123# 查找php [ 视图模式下，通过“/php” 查找。]$ : 删除行首注释&quot;#&quot; 123# 保存并退出$ : x 3、切换目录，复制php.ini文件 123$ cd /etc$ sudo cp php.ini.default php.ini 4、重启apache服务器 1$ sudo apachectl -k restart 注意⚠： 每次需手动重启Apache服务器 1$ sudo apachectl -k start 执行脚本，显示拒绝访问（格式NTFS，修改权限） 123$ chmod 644 info.php &quot; (没有权限的文件名)$ chmod 644 *.* ［ 每日一句 ］ “ When in doubt, use brute force. “ – Ken Thompson ［ 每天一首英文歌 ］ “ Summertrain “ – Greyson Chance]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC * 夜间模式]]></title>
    <url>%2F2017%2F07%2F07%2FREVIEW%2F%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 DKNightVersion框架：实现夜间模式 GitHub：https://github.com/draveness/DKNightVersion.git 1、管理类的头文件 NightVersionManager.h 定义宏，通过RGB获取颜色！ 1#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] 定义头文件.h 12345678910111213141516typedef enum : NSUInteger &#123; DKThemeVersionNormal, DKThemeVersionNight,&#125; DKThemeVersion;extern NSString *const DKNightVersionNightFallingNotification;extern NSString *const DKNightVersionDawnComingNotification;extern CGFloat const DKNightVersionAnimationDuration;@interface DKNightVersionManager : NSObject+ (DKThemeVersion)currentThemeVersion;+ (void)nightFalling;+ (void)dawnComing;+ (BOOL)useDefaultNightColor;+ (void)setUseDefaultNightColor:(BOOL)use; 2、核心代码 NightVersionManager.m 2.1 单例、保证工具类对象，只被分配一次内存 123456789+ (DKNightVersionManager *)sharedNightVersionManager &#123; static dispatch_once_t once; static DKNightVersionManager *instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; instance.useDefaultNightColor = YES; &#125;); return instance;&#125; * 2.2 设置主题的版本 1234567891011- (void)setThemeVersion:(DKThemeVersion)themeVersion &#123; if (_themeVersion == themeVersion) &#123; // if type does not change, don&apos;t execute code below to enhance performance. return; &#125; _themeVersion = themeVersion; [self changeColor:[[UIApplication sharedApplication].delegate.window.subviews firstObject]];&#125;``` * 2.3 改变颜色－－委托 - (void)changeColor:(id &lt;DKNightVersionSwichColorProtocol&gt;)object { if ([object respondsToSelector:@selector(changeColor)]) { [object changeColor]; } if ([object respondsToSelector:@selector(subviews)]) { if (![object subviews]) { // Basic case, do nothing. return; } else { for (id subview in [object subviews]) { // recursice darken all the subviews of current view. [self changeColor:subview]; if ([subview respondsToSelector:@selector(changeColor)]) { [subview changeColor]; } } } } } 12* 2.4 设置模式的颜色 + (BOOL)useDefaultNightColor { return self.sharedNightVersionManager.useDefaultNightColor; } + (void)setUseDefaultNightColor:(BOOL)use { [self.sharedNightVersionManager setUseDefaultNightColor:use]; } 1234* 3、控件分类（UIButton、UILabel、UIScrollView等） * 3.1 UIButton+NightVersion.m - (void)changeColor { [UIView animateWithDuration:DKNightVersionAnimationDuration animations:^{ [self setTitleColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightTitleColor : self.normalTitleColor forState:UIControlStateNormal]; [self setBackgroundColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightBackgroundColor : self.normalBackgroundColor]; [self setTintColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightTintColor : self.normalTintColor]; }]; } 12* 3.2 UIButton+TitleColor.m // 加载时GCD，保证线程安全。 // runtime运行时，SEL &amp; Method的使用。 + (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(setTitleColor:forState:); SEL swizzledSelector = @selector(hook_setTitleColor:forState:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod){ class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } 12* 设置默认的标题颜色 (UIColor *)defaultNightTitleColor { if ([self isMemberOfClass:[UIButton class]]) { return UIColorFromRGB(0x5F80AC); } else { UIColor *resultColor = self.normalTitleColor ?: [UIColor clearColor]; return resultColor; }} 1234* 4、Test测试 * 4.1 AppDelegate.m (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible]; UINavigationController *navigation = [[UINavigationController alloc] initWithRootViewController:[[RootViewController alloc] init]]; self.window.rootViewController = navigation; return YES;} 12* 4.2 RootViewController.m (void)nightFalls { [DKNightVersionManager nightFalling];} (void)dawnComes { [DKNightVersionManager dawnComing];} (void)push { [self.navigationController pushViewController:[[SuccViewController alloc] init] animated:YES];} 12* 4.3 SuccViewController.m (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.view.nightBackgroundColor = [UIColor colorWithRed:0.141 green:0.145 blue:0.153 alpha:1.0];}` ［ 每日一句 ］ “ Smiling is the best reaction in all situations. “ ［ 推荐网站 ］ http://www.umeng.com]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法]]></title>
    <url>%2F2017%2F07%2F04%2FREVIEW%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、A 搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A搜索算法是最佳优先搜索的范例。 2、集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。 3、二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。 4、分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。 5、Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。 6、数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。 7、Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。 8、Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。 9、离散微分算法（Discrete differentiation） 10、动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法 11、欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。 12、期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。 13、快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。 14、梯度下降（Gradient descent）——一种数学上的最优化算法。 15、哈希算法（Hashing） 16、堆排序（Heaps） 17、Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。 18、LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。 19、最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。 20、合并排序（Merge Sort） 21、牛顿法（Newton’s method）——求非线性方程（组）零点的一种重要的迭代法。 22、Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。 23、两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。 24、RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。 25、RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。 26、Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。 27、单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。 28、奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。 29、求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。 30、Strukturtensor算法——应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。 31、合并查找算法（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作： 查找：判断某特定元素属于哪个组。 合并：联合或合并两个组为一个组。 32、维特比算法（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡算法、编译、预处理]]></title>
    <url>%2F2016%2F06%2F14%2FREVIEW%2F%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[［ Bubble Sort ］ 简述： 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。冒泡排序的最坏时间复杂度为 O(n*n) 原理如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************* &gt; File Name: bubble.c &gt; Author: SpongeBob_Han (Bing Ma) &gt; Mail: 1605319671@qq.com &gt; Created Time: Sat Apr 18 16:27:34 2015************************************************************************//* blcok的使用 &amp; 调用系统清屏“clear” */#include&lt;stdio.h&gt;//#define swap(a, b) &#123; \int temp; temp = a; a = b; b = temp;\&#125;//#define MAX(x,y) (x)&gt;(y)?(x):(y)#pragma - 利用block打印出结果！void (^print)(int *, int) = ^(int a[], int n)&#123; int index; for(index = 0; index &lt; n; index++) printf(&quot;%d \t&quot;, a[index]);&#125;; #pragma - 引入终端命令“clear”等！int system(const char *string);void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125; Buble Sort 核心算法： 123456789101112131415161718#pragma - Bubble Sort !void bubble(int a[], int n)&#123; int i, j; for (i = 0; i &lt; n-1; ++i) for (j = n-1; j &gt; i; --j) if (a[j-1] &gt; a[j]) swap(&amp;a[j-1], &amp;a[j]); // print(a, n);&#125; 123456789101112131415161718192021// main.cint main()&#123; // 调用系统clear system(&quot;clear&quot;); printf(&quot;Bubble sort! \n\n&quot;); int a[] = &#123;7, 3, 66, 3, -5, 22, 77, 2&#125;; // 调用函数bubble bubble(a, 8); print(a, 8); printf(&quot;\n\n&quot;); return 0;&#125; 总结： 1、冒泡排序效率非常低 2、如果数组中包含n个元素，那么比较次数的复杂度：n * n 3、使用“归并”排序，高效率，复杂度：n log n ［ 每日一句 ］ “不要把期望放到别人那，你要知道，你未来要去哪儿？” ［ 每天一首英文歌 ］ “ When You’re Gone “ - Avril Lavigne]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppleScript]]></title>
    <url>%2F2016%2F06%2F08%2FREVIEW%2FAppleScript%2F</url>
    <content type="text"><![CDATA[定义：苹果公司开发的一种脚本语言，可以用来控制运行于Mac OS上的程序，也可以写成独立运行的Applet。 用处：可用于操控其他软件。 脚本例子： 12345tell application &quot;Finder&quot;get name of every diskend tell ==&gt; Result: 1&#123;&quot;Mac_SSD&quot;, &quot;Win8.1&quot;, &quot;home&quot;, &quot;net&quot;&#125; 2. 1234567891011tell application &quot;Finder&quot;set L to get every diskmy getNameof(1)end tellon getNameof(what)global Llocal sset s to get name of item what of Lreturn send getNameof ==&gt; Result: 1&quot;Mac_SSD&quot; 分享：AppleScript资料下载 |–&gt; Download ［ 每日一句 ］ “每个人，都有自己的一种活法。” ［ 每天一首英文歌 ］ “ Whistle “ - Flo Rida]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN & Git （二）]]></title>
    <url>%2F2016%2F03%2F04%2FREVIEW%2FSVN_Git_%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Git： 一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 利用Terminal终端！ Git 配置 利用SSH配置Git 123456789101112131415161718192021222324252627282930SSH1、创建SSH：$ ssh-keygen -t rsa -C “xxxx@xxx.com&quot; 2、将公钥添加到剪贴板，再添加(粘贴)到网页中$ pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard3、本地验证：$ eval &quot;$(ssh-agent -s)&quot; $ ssh-add ~/.ssh/git_os_rsa $ ssh -T git@git.oschina.net 4、导入工程：$ git clone https://github.com/xxx/xxxxx 配置仓库 123$ git config --global user.name &quot;YOUR NAME&quot;$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; 初始化仓库 12345git initgit add .git commit -m “ProjectName&quot; 自定义Git命令： 1$ git config alias.cf “commit -m&quot; 添加.gitignore 脚本命令： 12345678910111213141516171819202122echo -e &quot;# Xcode#build/*.pbxuser*.mode1v3*.mode2v3*.perspectivev3xcuserdata*.xccheckout*.moved-asideDerivedData*.hmap*.ipa*.xcuserstate# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control## Pods/&quot; &gt; .gitignore 将.gitignore添加到代码库 1$ git add .gitignore 自定义快捷键： 123# 进入目录$HOME/.bashrc 或 $HOME/.bash_profile 123456789# 编辑内容 alias ll=&quot;ls -l&quot;alias cls=“clear”alias gc=&quot;git clone&quot;export CLICOLOR=1 1、将GitHub中的默认邮箱，修改为用户邮箱。（不能使用它自己的默认邮箱） 2、在提交过程中，一定要忽略［User Data］&amp;［Shared Data］文件！ ［ 每日一句 ］ 逝去的东西，最好不见，最好不念。 ［ 每天一首英文歌 ］ “ This Love “ – Taylor Swift]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN & Git （一）]]></title>
    <url>%2F2016%2F03%2F04%2FREVIEW%2FSVN_Git_%E4%B8%80%2F</url>
    <content type="text"><![CDATA[（一）SVN的使用、CornerStone图形化管理工具！简介 SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。 svn服务器，2种运行方式：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择。 svn存储数据，2种：BDB(一种事务安全型表类型)和FSFS(一种不需要数据库的存储系统)。因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。 详见SVN。 利用Terminal终端！ 1.将服务器文件下载到本地 1234567# 切换工作目录$ cd 经理的工作目录# checkout服务器上的代码仓库$ svn co http://192.168.1.103/svn/xxx --username=manager --password=manager 提示：checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 经理添加文件 svn 常用命令123456789# 查看本地代码库状态$ svn st错误提示：&quot;is not a working copy&quot;，必须在svn的工作目录下才能正确使用svn的命令# 查看svn日志$ svn log 1234567# 查看某一个文件的日志$ svn log filename# 查看某一个文件某个版本的日志$ svn log filename@1 创建文件 1234567# 切换到工作目录$ cd weibo# 创建文件$ touch main.c 1234567# 打开并编写文件内容$ open main.c * 将文件提交到服务器 1234567# 查看工作目录状态$ svn st# 将文件添加到本地版本库中$ svn add main.c 123# 将文件提交到服务器的版本库中$ svn ci -m &quot;添加了main.c文件&quot; “小结” - 添加文件的两个步骤 1&gt; 将新建的文件添加到本地代码库 1$ svn add main.c 2&gt; 将刚刚添加的文件提交到服务器 1$ svn ci -m &quot;备注信息&quot; 注意：一定要养成写注释的良好习惯 团队成员加入 1&gt; 张三 1$ svn co http://10.0.1.15/svn/weibo --username=zhangsan --password=zhangsan 2&gt; 李四 1$ svn co http://10.0.1.15/svn/weibo --username=lisi --password=lisi “小结” 至此，一个项目的搭建工作就告一段落了 1&gt; 项目准备工作，通常由项目经理完成 2&gt; 程序员只需要把项目 co 到本地即可 提示：新入职一家公司后，别忘记让经理分配 svn 的账号和密码 张三添加文件 12345678910111213# 添加文件 Person.h Person.m$ touch Person.h Person.m# 修改 Person.h Person.m$ open Person.h$ open Person.m# 将 Person.h Person.m 添加到本地代码库$ svn add Person.* 123# 将内容提交到服务器$ svn ci -m &quot;添加了Person类&quot; 删除文件 12345678910111213141516# 删除文件$ svn rm Person.h# 提交删除$ svn ci -m &quot;删除了文件&quot;``` 注意：不要使用文件管理器直接删除文件 * 06. 撤销修改--- $ svn revert Person.m123 * 07. 恢复到之前的某个版本 $ svn update -r 5 $ svn up12 * 08. 冲突解决 (p) postpone 对比 (mc) mine-conflict 使用我的 (tc) theirs-conflict 使用对方的123456789101112131415161718192021222324 ---### 图形界面 * 1.安装CornerStone 下载最新版本，安装。 * 2.具体操作 * 1&gt; 添加远程代码仓库 * 2&gt; 导出代码库到本地 * 3&gt; 在本地目录下使用Xcode新建项目 注意：不要勾选 git，两套源代码管理同时存在会发生冲突 * 4&gt; 提交到代码仓库 * 5&gt; 其他用户操作* 3.忽略一些不需要上传的文件 .ignore` 4.SVN演练 1&gt; 修改viewcontroller,提交 2&gt; 添加Person类,提交 3&gt; 代码冲突演示 4&gt; storyboard冲突演示 5&gt; 利用storyboard查看历史版本,回退 6&gt; 利用xcode checkout 项目 5.目录规范 1&gt; Trunk 目前项目正在开发的版本 通常进入公司之后在该目录下开发 2&gt; Tags 存放已经上线的重大版本 3&gt; Branches 当发生重大bug或者有新需求时]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树/堆/栈]]></title>
    <url>%2F2015%2F10%2F27%2FREVIEW%2F%E4%BA%8C%E5%8F%89%E6%A0%91_%E5%A0%86_%E6%A0%88%2F</url>
    <content type="text"><![CDATA[简介数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 逻辑结构包括： 1.集合数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系； 2.线性结构数据结构中的元素存在一对一的相互关系； 3.树形结构数据结构中的元素存在一对多的相互关系； 4.图形结构数据结构中的元素存在多对多的相互关系。 链表：1、对于，数据结构、堆栈的简单总结。 2、链表的操作！ 1.&gt; 数据结构 2.&gt; 自引用结构 1234567struct list &#123; int data; struct list *next;&#125; a; 3.&gt; 线性链表 12345678910111213141516171819/* list.h: */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char DATA; /* will use char in examples. */struct linked_list &#123; DATA d; struct linked_list *next;&#125;;typedef struct linked_list ELEMENT;typedef ELEMENT *LINK; 4.&gt; 链表操作 123456789101112131415161718192021222324252627#include &quot;list.h&quot;#include &lt;stdlib.h&gt;LINK string_to_list(char s[])&#123; LINK head; if (s[0] == &apos;\0&apos;) /* base case. */ return NULL; else &#123; head = malloc(sizeof(ELEMENT)); head -&gt; d = s[0]; head -&gt; next = string_to_list(s+1); return head; &#125;&#125; a.插入（insert） 12345678910111213/* Inserting an element in a linked list. */void insert(LINK p1, LINK p2, LINK q)&#123; assert(p1 -&gt; next == p2); p1 -&gt; next = q; /* insert */ q -&gt; next = p2;&#125; 删除（delete） 123456789101112131415/* Recursive deletion of a list. */void delete_list(LINK head)&#123; if (head != NULL) &#123; delete_list(head -&gt; next); free(head); /* release storage */ &#125;&#125; 堆栈 堆栈（压入、弹出） 堆栈、是暂时存放数据和地址，通常用来保护断点和现场； 堆，队列优先,先进先出(First-In/First-Out)； 栈，先进后出(First-In/Last-Out)。 ADT Stack（堆栈） 只能在一端(称为栈顶(top))对数据项进行插入和删除 push（压入＝＝增）、pop（弹出＝＝删）、top（取顶部元素＝＝查）、empty（判断是否为空）、full（判断是否已满）和reset（重置＝＝init） 堆栈的区别：一般栈区中的内存，系统会自己管理；作为程序员，我们只需管理堆区的内存分配&amp;释放！ 比喻： 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 二叉树 简介： 树（tree）是一种称为节点（node）的元素的有限集合。 树具有一个唯一节点（根节点）,每个节点最多具有2个子节点（左孩子、右孩子）。 叶节点、它的左右孩子节点为NULL 遍历(Traversal) 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问！ 树的遍历：1、沿链表移动；2、根据下标访问，指向链表的数组元素。 ［ 通过根节点访问时间决定 ］ 创建BTREE123456789101112131415161718192021222324252627/* Creating a binary tree. */ BTREE new_node(void) &#123; return (malloc(sizeof(NODE))); &#125; BTREE init_node (DATA d1, BTREE p1, BTREE p2) &#123; BTREE t; t = new_node(); t -&gt; d = d1; t -&gt; left = p1; t -&gt; right = p2; return t; &#125; 中序（inorder）： 先访问左子树，再访问根节点 左－&gt;根－&gt;右（必须递归遍历完后，再进行下一步） 12345678910111213141516171819202122232425262728 // Binary Tree /* Inorder binary tree traversal. */ void inorder (BTREE root) &#123; if (root != NULL) &#123; inorder(root -&gt; left); /* recur left */ printf(&quot;%c&quot;, root -&gt; d); inorder(root -&gt; right); /* recur right */ &#125; &#125; /* Output: A B C D E F G H I J */ ``` #### 前序（preorder）： * 先访问根节点 * **根－&gt;左－&gt;右** // [ preorder ] / Preorder and postorder binary tree traversal. / void preorder (BTREE root) { if (root != NULL) { printf(&quot;%c&quot;, root -&gt; d); preorder(root -&gt; left); /* recur left */ preorder(root -&gt; right); /* recur right */ } } / Output: G D B A C F E I H J / 12345#### 后序（postorder）：* 访问完左右子树后，才访问根节点* **左－&gt;右－&gt;根** // [ postorder ] void postorder (BTREE root) { if (root != NULL) { postorder(root -&gt; left); /* recur left */ postorder(root -&gt; right); /* recur right */ printf(&quot;%c&quot;, root -&gt; d); } } / Output: A C B E F D H J I G / ` 总结 1 抽象数据类型（ADT）堆栈可以使用链表来实现，对它的限制在它的第一个元素（称为顶部）。堆栈具有后进先出（LIFO）的特性，这个行为是由push()和pop()函数实现。 2 ADT队列也可以用链表来实现，对它的访问限制在它的头部和尾部。队列具有先进先出（FIFO）的特性，这个行为是由enqueue()和dequeue()函数实现的。 3 当算法使用迭代方式实现时，需要使用一个迭代循环，在监测到NULL时终止。迭代算法的代价是需要使用辅助指针，但它的效率一般高于递归算法。 4 链表处理的标准算法用递归来实现非常自然。基本条件常常就是检测到NULL链。一般条件通过在链表结构中移动链来进行递归。 5 二叉树由包含两个链成员的结构来表示，它组合了线性链表的动态特征，并且可以非常快地访问树中的每个元素。二叉树的元素之间的距离通常是对数级的。 6 二叉树最常用使用三种遍历方法。每种访问方法是通过根节点的访问时间决定的。这三种遍历方式都可以用递归来实现，从左向右链接每棵子树。 7 PS：自引用结构使用指针来访问相同类型结构的地址！！最简单的自引用结构是线性链表。每个元素指向它的下一个元素，最后一个元素指向NULL。 8 malloc()函数用于动态内存分配。free()函数用于释放参数所指向的内存，把它返回给系统，供以后使用。 9 我们可以指定同时涉及链表和数组的具有可怕复杂性的数据结构。其中一个例子就是实现普通树。在普通树中，每个节点可以具有任意数量的孩子。节点的孩子由链表来表示，它由一个头元素数组所指向。 ［ 每日一句 ］ “Nowadays, I don’t really know where I’m going, but I hope I go far. ” ［ 每天一首英文歌 ］ “ This Love “ - Taylor Swift]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 字典]]></title>
    <url>%2F2015%2F07%2F17%2FREVIEW%2FSwift_%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[1import UIKit 字典: 存储一组无序数据OC: 12345678NSDictionary *dict = [NSDictionary dictionaryWithObject:@&quot;bing&quot; forKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict);NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];NSLog(@&quot;%@&quot;, dict);NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;bing&quot;, @&quot;age&quot;:@30&#125;;NSLog(@&quot;%@&quot;, dict); Swift: 1234567891011121314151617181920212223// key一定要是可以hash的(String, Int, Float, Double, Bool), value没有要求var dict0 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict0)var dict1:Dictionary = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict1)var dict2:Dictionary&lt;String,Any&gt; = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict2)var dict3:[String:Any] = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict3)var dict4:[String:Any] = Dictionary(dictionaryLiteral: (&quot;name&quot;, &quot;bing&quot;), (&quot;age&quot;, 30))println(dict4)//空字典:var dict01:Dictionary&lt;String,Any&gt; = [:]var dict02 = Dictionary&lt;String,Any&gt;()var dict03 = [String:Any]()//不可变数组:var dict:Dictionary&lt;String,Any&gt; = [:]//可变数组:let dict:Dictionary&lt;String,Any&gt; = [:] 字典操作OC: 123456789101112//1.获取NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;bing&quot;, @&quot;age&quot;:@30&#125;;NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]);//2.修改NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];dict[@&quot;name&quot;] = @&quot;iversion&quot;;NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];[dict setObject:@&quot;iversion&quot; forKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]); Swift: 1234567891011121314151617181920212223242526272829303132//1.获取var dict04 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict04[&quot;name&quot;]!)//2.修改var dict05 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict05[&quot;name&quot;] = &quot;iverson&quot;println(dict05[&quot;name&quot;]!)var dict06 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict06.updateValue(&quot;iverson&quot;, forKey: &quot;name&quot;)println(dict06[&quot;name&quot;]!)var dict08 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// updateValue返回一个可选类型, 如果字典中不存在需要更新的key, 那么返回nil, 如果存在返回原始值if let orignal = dict08.updateValue(&quot;iverson&quot;, forKey: &quot;name&quot;)&#123;println(dict08[&quot;name&quot;]!)println(orignal)&#125;var dict07 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// updateValue返回一个可选类型, 如果字典中不存在需要更新的key, 那么返回nil并且会将新的键值对添加到字典中if let orignal = dict07.updateValue(&quot;iverson&quot;, forKey: &quot;abc&quot;)&#123;println(dict07[&quot;abc&quot;]!)println(orignal)&#125;println(dict07) 添加字典 OC: 12345678NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];dict[@&quot;height&quot;] = @175;NSLog(@&quot;%@&quot;, dict);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];[dict setObject:@175 forKey:@&quot;height&quot;];NSLog(@&quot;%@&quot;, dict); Swift: 123var dict09 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict09[&quot;height&quot;] = 175;println(dict09) ** 删除字典OC: 1234567NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict removeObjectForKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict removeAllObjects];NSLog(@&quot;%@&quot;, dict); Swift: 1234567891011121314151617var dict_1 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict_1.removeValueForKey(&quot;name&quot;)println(dict_1)var dict_2 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// removeValueForKey返回一个可选类型, 如果字典中不存在需要删除的key, 那么返回nil并且不会执行任何操作, 如果存在则删除key对应的值, 并且返回被删除的值if let orignal = dict_2.removeValueForKey(&quot;names&quot;)&#123;println(dict_2)println(orignal)&#125;println(dict_2)var dict_3 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict_3.removeAll(keepCapacity: true) 遍历字典OC: 12345678910111213141516NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;NSLog(@&quot;key = %@ value = %@&quot;, key, obj);&#125;];NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];NSArray *keys = [dict allKeys];for (NSString *key in keys) &#123;NSLog(@&quot;%@&quot;, key);&#125;NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];NSArray *values = [dict allValues];for (NSString *value in values) &#123;NSLog(@&quot;%@&quot;, value);&#125; Swift: 1234567891011121314151617181920212223var dict_a = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for (key , value) in enumerate(dict_a)&#123;println(&quot;key = \(key) value = \(value)&quot;)&#125;var dict_b = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for key in dict_b.keys &#123;println(&quot;key = \(key)&quot;)&#125;var dict_c = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for value in dict_c.values&#123;println(&quot;value = \(value)&quot;)&#125;var dict_d = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for (key , value) in dict_d&#123;println(&quot;key = \(key) value = \(value)&quot;)&#125;]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 数组]]></title>
    <url>%2F2015%2F07%2F14%2FREVIEW%2FSwift_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1import UIKit 数组: 存储一组有序的数据 OC: 有值数组: 123NSArray *arr0 = @[@1, @2, @3];NSArray *arr1 = [NSArray arrayWithObjects:@1, @2, @3, nil];NSLog(@&quot;%@&quot;, arr1); 空数组 123NSArray *arr2 = @[];NSArray *arr3 = [NSArray array];NSLog(@&quot;%@&quot;, arr3); 不可变数组:NSArray可变数组:NSMutableArray Swift: 1234567891011121314151617// 有值数组var arr0 = [1, 2, 3]var arr1: Array = [1, 2, 3]var arr2: Array&lt;Int* = [1, 2, 3]var arr3: [Int] = [1, 2, 3]//var arr4: Int[] = [1, 2, 3] 早期写法// 空数组var arr5 = []var arr6 = [Int]()var arr7 = Array&lt;Int* ()// 带初始值的数组var arr8 = Array(count: 5, repeatedValue: 1)println(arr8)// 不可变数组:var arr0 = []// 可变数组:let arr0 = [] 元素类型OC: 12NSArray *arr = @[@1, @&quot;lnj&quot;, @1.75];NSLog(@&quot;%@&quot;, arr); Swift: 12var arr_02 = [1, &quot;lnj&quot;, 1.75]println(arr_02) 如果想明确表示数组中存放的是不同类型的数据, 可以使用Any关键字, 表示数组中可以存放不同类型的数据 12var arr:Array&lt;Any* = [1, &quot;lnj&quot;, 1.75]println(arr) 数组操作 1.获取长度OC: 12NSArray *arr = @[@1, @2, @3];NSLog(@&quot;%tu&quot;, arr.count); Swift: 12var arr = [1, 2, 3]println(arr.count) 2.判断是否为空OC: 12NSArray *arr = @[];NSLog(@&quot;%d&quot;, arr.count != 0); Swift: 12var arr_01 = [1, 2, 3]println(arr_01.isEmpty) 3.检索OC: 12NSArray *arr = @[@1, @2, @3];NSLog(@&quot;%@&quot;, arr[0]); Swift: 12var arr = [1, 2, 3]println(arr[0]) 4.追加OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr addObject:@4];NSLog(@&quot;%@&quot;, arr); Swift: 12345678910var arr02 = [1, 2, 3]arr02.append(4);println(arr02)var arr03 = [1, 2, 3]arr03 += [4]// arr03 += 4 以前的版本可以这样写//arr03 += [5, 6, 7]arr03 += arr03[0...1] // 还可以自己搞自己println(arr03) 5.插入OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr insertObject:@4 atIndex:0];NSLog(@&quot;%@&quot;, arr); Swift: 123var arr = [1, 2, 3]arr.insert(4, atIndex: 0);println(arr) 6.更新OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];arr[0] = @8;NSLog(@&quot;%@&quot;, arr); Swift: 1234567var arr01 = [1, 2, 3]arr01[0] = 8println(arr01)var arr0002 = [1, 2, 3]arr0002[0..&lt;2] = [8, 9]println(arr0002) 7.删除OC: 1234567891011NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeObject:@1];NSLog(@&quot;%@&quot;, arr);NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeLastObject];NSLog(@&quot;%@&quot;, arr);NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeAllObjects];NSLog(@&quot;%@&quot;, arr); Swift: 123456789101112var arr001 = [1, 2, 3]arr001.removeAtIndex(0)println(arr001)var arr002 = [1, 2, 3]arr002.removeLast()println(arr002)var arr003 = [1, 2, 3]arr003.removeAll(keepCapacity: false) //是否保持容量, 如果为true, 即便删除了容量依然存在, 容量是2的倍数println(arr003)println(arr003.capacity) 注意: 如果数组是一个不可变数组不能更新/插入和删除第一个版本的不可变数组是可以修改的 RangeOC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeObjectsInRange:NSMakeRange(0, 2)];NSLog(@&quot;%@&quot;, arr); Swift: 123456789101112131415161718192021var arr_1 = [1, 2, 3]arr_1.removeRange(Range(start: 1, end: 2))println(arr_1)var arr_2 = [1, 2, 3]arr_2.removeRange(0...0)println(arr_2)// 其实Range就是半闭区间var range = 0...5//range = 99 // 通过报错可以推断出类型println(range) // 通过打印也可以推断出类型var range1:Range&lt;Int* = 0...5//var range2:Range&lt;String* ; // 必须遵守ForwardIndexType协议// start 起点 end 终点var range3:Range&lt;Int* = Range(start: 0, end: 5)var range4:Range&lt;Int* = 0..&lt;5println(range1)println(range3)println(range4) OC: 12345NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];NSRange range = NSMakeRange(0, 2);// [arr replaceObjectsInRange:range withObjectsFromArray:@[@99, @88]];[arr replaceObjectsInRange:range withObjectsFromArray:@[@99, @88, @77, @66]];NSLog(@&quot;%@&quot;, arr); Swift: 12345678910111213//arr.replaceRange(Range(start: 0, end: 2), with: [99, 88, 77, 66])arr.replaceRange(1..&lt;2, with: [99, 88, 77, 66])println(arr)// 等价于上一行代码var arr_3 = [1, 2, 3]arr_3[Range(start: 0, end: 2)] = [8, 9]println(arr_3)// 等价于上一行代码var arr_4 = [1, 2, 3]//arr[0...1] = [99, 88]//arr[0...1] = [99, 88, 77, 66] 遍历OC: 12345678910111213141516// for循环NSArray *arr = @[@1, @2, @3];for (int i = 0; i &lt; arr.count; i++) &#123;NSLog(@&quot;%@&quot;, arr[i]);&#125;// for in循环for (NSNumber *number in arr) &#123;NSLog(@&quot;%@&quot;, number);&#125;// 迭代器NSArray *arr0 = @[@1, @2, @&quot;1&quot;];[arr0 enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;NSLog(@&quot;index = %tu element = %@&quot;, idx, obj);&#125;]; Swift: 12345678910111213141516171819202122232425262728293031// for循环var arr_a = [1, 2, 3]for var i = 0 ; i &lt; arr_a.count ; i++&#123;println(arr_a[i])&#125;// for in循环for number in arr_a&#123;println(number)&#125;for i in 0..&lt;arr_a.count&#123;println(arr_a[i])&#125;// 取出数组中某个区间范围的值var arr_b = [1, 2, 3]for number in arr_b[0..&lt;3]&#123;println(number)&#125;// 利用enumerate迭代var arr_c = [1, 2, 3]for (index , value) in enumerate(arr_c)&#123;println(&quot;index = \(index) value = \(value)&quot;)&#125;]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 异常处理]]></title>
    <url>%2F2015%2F07%2F09%2FREVIEW%2FSwift_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[面向轨道编程 - Swift 中的异常处理 问题在开发过程中，异常处理算是比较常见的问题了。 举一个比较常见的例子：用户修改注册的邮箱，大概分为以下几个步骤： 接收到一个用户的请求：我要修改邮箱地址 验证一下请求是否合法，将请求进行格式转化 更新以前的邮箱地址记录 给新的邮箱地址发送验证邮件 将结果返回给用户上面的步骤如果一切顺利，那代码肯定干净利落，但是人生不如意十有八九，上面的步骤很容易出现问题： 用户把邮箱地址填成了家庭地址 用户是个黑客，没登录就发送了更新请求 发送验证邮件的时候服务器爆炸了，发送邮件失败各种异常都会导致这次操作的失败。 方案一在传统的处理方案里，一般是遇到异常就往上抛： 这种方案想必大家都不陌生，比如下面这段代码： 1234567891011121314NSError *err = nil;CGFloat result = [MathTool divide:2.5 by:3.0 error:&amp;err];if (err) &#123; NSLog(@&quot;%@&quot;, err)&#125; else &#123; [MathTool doSomethingWithResult:result]&#125; 方案二而另一种方案，则是将错误的结果继续往后传，在最后统一处理： 这种方案有两个问题： 在发生异常的时候，如何把异常继续传给下面的函数？ 当整个流程结束的时候，一个函数如何输出多个结果？ 车轨 我们把方案二抽象出来，就像是一段车轨： 对于同一个输入，会有 Success 和 Failure 两种输出结果，对于 Success 的情况，我们希望它能继续走到后面的流程里，而对于 Failure 的情况，它怎么处理并不重要，我们希望它能避开后面的流程： 于是乎，两段车轨拼接的时候，便成了这样： 那么三段什么的自然也不在话下了。我们把下面那根 Failure 的线路扩展一下，便会看到两条平行的线路，这便是“双轨模型” (Two Track Model) ，这是用“面向轨道编程”思想解决异常处理的理论基础。 这就是 “面向轨道编程” 。一开始我觉得这概念应该只是来搞笑的，仔细想想似乎倒也是很贴切。将事件流当做两条平行的轨道，如果顺利则在上行轨道，继续传递给下个业务逻辑去处理，如果出现异常也不慌，直接扔到下行轨道，一直在下行轨道传递到终点，在最后统一处理。 这样处理使得整个流程变成了一条双进双出的流水线，有点像是 shell 里的 pipeline ，上一次的输出作为下一次的输入，十分顺畅。而且拼接起来也很方便，我们可以把三段拼接成一段暴露给其他对象使用： 实现接下来看看在 Swift 中如何应用这种思路处理异常。 首先我们需要两种类型的输出结果： 成功，返回某种类型的值 失败，返回一个 Error 对象或者失败的具体信息照着这个想法，我们可以定义一个 Result 枚举用做输出： 1234567enum Result&lt;T&gt; &#123; case Success(T) case Failure(String) &#125; 利用 Swift 的枚举特性，我们可以在成功的枚举值里关联一些返回值，然后在失败的情况下则带上失败的消息内容。不过 enum 目前还不支持泛型，我们可以在外面封装一个 Box 类来解决这个问题： 1234567891011121314151617final class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125; enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String)&#125; 再看下一开始我们举的那个例子，用这个枚举类重新写下就是这样的： 12345678910111213var result = divide(2.5, by:3)switch result &#123;case .Success(let value): doSomethingWithResult(value)case .Failure(let errString): println(errString)&#125; “看起来好像也没什么嘛，你不还是用了个大括号处理两种情况嘛！”（嫌弃脸 确实正如这位热情的朋友所说，写完这个例子我也没觉得有什么优点，难道我就是来搞笑的？ “并不。”（严肃脸 栗子 接下来我们举个栗子玩一玩。为了更好的观赏效果，请允许我使用浮夸的写法和粗暴的命名举这个栗子。 比如对于即将输入的数字 x ，我们希望输出 4 / (2 / x - 1) 的计算结果。这里会有两处出错的可能，一个是 (2 / x) 时 x 为 0 ，另一个就是 (2 / x - 1) 为 0 的情况。 先看下传统写法： 123456789101112131415161718192021222324252627282930313233let errorStr = &quot;输入错误，我很抱歉&quot;func cal(value: Float) &#123; if value == 0 &#123; println(errorStr) &#125; else &#123; let value1 = 2 / value let value2 = value1 - 1 if value2 == 0 &#123; println(errorStr) &#125; else &#123; let value3 = 4 / value2 println(value3) &#125; &#125;&#125;cal(2) // 输入错误，我很抱歉cal(1) // 4.0cal(0) // 输入错误，我很抱歉 那么用面向轨道的思想怎么去解决这个问题呢？ 大概是这个样子的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125; enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String)&#125;let errorStr = &quot;输入错误，我很抱歉&quot; func cal(value: Float) &#123; func cal1(value: Float) -&gt; Result&lt;Float&gt; &#123; if value == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(value: 2 / value)) &#125; &#125; func cal2(value: Result&lt;Float&gt;) -&gt; Result&lt;Float&gt; &#123; switch value &#123; case .Success(let v): return .Success(Box(value: v.value - 1)) case .Failure(let str): return .Failure(str) &#125; &#125; func cal3(value: Result&lt;Float&gt;) -&gt; Result&lt;Float&gt; &#123; switch value &#123; case .Success(let v): if v.value == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(value: 4 / v.value)) &#125; case .Failure(let str): return .Failure(str) &#125; &#125; let r = cal3(cal2(cal1(value))) switch r &#123; case .Success(let v): println(v.value) case .Failure(let s): println(s) &#125; &#125;cal(2) // 输入错误，我很抱歉cal(1) // 4.0cal(0) // 输入错误，我很抱歉 同学，放下手里的键盘，冷静下来，有话好好说。 反思 面向轨道之后，代码量翻了两倍多，而且似乎变得更难读了。浪费了大家这么多时间结果就带来这么个玩意儿，实在是对不起观众们热情的掌声。 仔细看下上面的代码， switch 的操作重复而多余，都在重复着把 Success 和 Failure 分开的逻辑，实际上每个函数只需要处理 Success 的情况。我们在 Result 中加入 funnel 提前处理掉 Failure 的情况： 12345678910111213141516171819202122enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String) func funnel&lt;U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; &#123; switch self &#123; case Success(let value): return f(value.value) case Failure(let errString): return Result&lt;U&gt;.Failure(errString) &#125; &#125;&#125; funnel 帮我们把上次的结果进行分流，只将 Success 的轨道对接到了下个业务上，而将 Failure 引到了下一个 Failure 轨道上。 接下来再回到栗子里，此时我们已经不再需要传入 Result 值了，只需要传入 value 即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func cal(value: Float) &#123; func cal1(v: Float) -&gt; Result&lt;Float&gt; &#123; if v == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(2 / v)) &#125; &#125; func cal2(v: Float) -&gt; Result&lt;Float&gt; &#123; return .Success(Box(v - 1)) &#125; func cal3(v: Float) -&gt; Result&lt;Float&gt; &#123; if v == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(4 / v)) &#125; &#125; let r = cal1(value).funnel(cal2).funnel(cal3) switch r &#123; case .Success(let v): println(v.value) case .Failure(let s): println(s) &#125;&#125; 看起来简洁了一些。我们可以通过 cal1(value).funnel(cal2).funnel(cal3) 这样的链式调用来获取计算结果。 “面向轨道”编程确实给我们提供了一个很有趣的思路。本文只是一个简单地讨论，进一步学习可以仔细阅读后面的参考文献。比如 ValueTransformation.swift 这个真实的完整案例，以及 antitypical/Result 这个封装完整的 Result 库。文中的实现方案只是一个比较简单的方法，和前两种实现略有差异。 面向铁轨，春暖花开。愿每段代码都走在 Happy Path 上，愿每个人都有个 Happy Ending 。 文章来源：http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 字符串]]></title>
    <url>%2F2015%2F07%2F09%2FREVIEW%2FSwift_%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1import UIKit 字符:Swift和OC字符不一样, Swift是用双引号. Swift中的字符类型和OC中的也不一样, OC中的字符占一个字节,因为它只包含ASCII表中的字符, 而Swift中的字符除了可以存储ASCII表中的字符还可以存储unicode字符, 例如中文OC的字符是遵守ASCII标准的,Swift的字符是遵守unicode标准的, 所以可以存放时间上所有国家语言的字符(大部分) OC: 12char charValue = &apos;a&apos;;char charValue = &apos;李&apos;; // 错误 Swift: 1234var charValue: Character = &quot;a&quot;var charValue1:Character = &quot;李&quot; //正确// 注意: 双引号中只能放一个字符, 如下是错误写法// Swift: var charValue:Character = &quot;ab&quot; 字符串:字符是单个字符的集合, 字符串是多个字符的集合, 想要存放多个字符需要使用字符串. 1C: char *stringValue = “ab”; char stringArr = “ab”; 12OC: NSString *stringValue = “ab”; 12Swift: var stringValue = “ab” 12* C语言中的字符串是以\0结尾的, 例如: char *stringValue = “abc\0bcd”; printf(“%s”, stringValue); 123 打印结果为abc* OC语言中的字符串也是以\0结尾的, 例如: NSString *stringValue = @”abc\0bcd”; NSLog(@”%@”, stringValue); 123 打印结果为abc* Swift中的字符串和C语言/OC语言中的字符串是不一样的 var stringValue = “ab” var stringValue1 = “abc\0bcd” println(stringValue) 123456字符串常用方法:* 计算字符串长度 C: char *stringValue = “abc李”; printf(“%tu”, strlen(stringValue)); 123打印结果6, 字节数OC: NSString *stringValue = @”abc李”; NSLog(@”%tu”, stringValue.length); 123打印结果4, 以UTF16计算Swift: Swift中的字符串是完全兼容unicode标准的 var stringValue2 = “abc李” println(count(stringValue2)) // 打印结果4, 无论以什么编码, 都是计算元素的个数 12345* 字符串拼接 C: char str1[] = “abc”; char str2 = “bcd”; char str = strcat(str1, str2); 1OC: NSMutableString str1 = [NSMutableString stringWithString:@”abc”]; NSString str2 = @”bcd”; [str1 appendString:str2]; NSLog(@”%@”, str1); 1Swift: var str1 = “abc”; var str2 = “bcd”; var str12 = str1 + str2; 123* 字符串格式化 OC: NSInteger index = 1; NSString *str1 = [NSMutableString stringWithFormat:@”http://www.trybst.com/pic/%tu.png&quot;, index]; NSLog(@”%@”, str1); 12Swift: var index = 1 var str3 = “http://www.trybst.com/pic/\(index).png&quot; println(str3) 1234* 字符串比较 OC: NSString str1 = @”abc”; NSString str2 = @”abc”; if ([str1 isEqualToString:str2]) { NSLog(@&quot;相等&quot;); } else { NSLog(@&quot;不相等&quot;); } if ([str1 compare:str2] == NSOrderedSame) { NSLog(@&quot;相等&quot;); } else { NSLog(@&quot;不相等&quot;); } 12Swift:(== / != / &gt;= / &lt;=), 和C语言的strcmp一样是逐个比较 var str10 = “abc”; var str20 = “abc”; if str10 == str20 { println(&quot;相等&quot;); } else { println(&quot;不相等&quot;); } var str11 = “abd”; var str21 = “abc”; if str11 &gt;= str21 { println(&quot;大于等于&quot;); } else { println(&quot;不大于等于&quot;); } 1234* 判断是否为空 OC: NSString *str1 = @”abc”; if (str1.length == 0) { NSLog(@”没有值”); }else{ NSLog(@”有值”); } 12Swift: var str0 = “abc” if str0.isEmpty { println(&quot;没有值&quot;) } else { println(&quot;有值&quot;) } 1234* 判断前后缀 OC: NSString *str = @”http://www.trybst.com&quot;; if ([str hasPrefix:@”http”]) { NSLog(@”是url”); } if ([str hasSuffix:@”.com”]) { NSLog(@”是国际域名”); } 12Swift: var str00 = “http://www.trybst.com&quot; if str00.hasPrefix(“http”) { println(&quot;是url&quot;); } if str00.hasSuffix(“.com”) { println(&quot;是国际域名&quot;); } 1234* 获取扩展名 OC: NSString *str = @”abc.txt”; NSLog(@”%@”, [str pathExtension]); 12Swift: var str02 = “abc.txt”; println(str02.pathExtension) 1234* 大小写转换 OC: NSString *str = @”abc.txt”; NSLog(@”%@”, [str uppercaseString]); NSLog(@”%@”, [str lowercaseString]); 1Swift: var str01 = “abc.txt”; println(str01.uppercaseString) println(str01.lowercaseString) 1234* 数据类型转换 OC: NSString *str = @”250”; NSInteger number = [str integerValue]; NSLog(@”%tu”, number); 12Swift: var str000 = “250” // 如果str不能转换为整数, 那么可选类型返回nil // str = “250sb” // 注意不要在转换时候(.toInt()!)强制解包, 如果不能转换又强制解包会触发运行时错误 var number:Int? = str000.toInt() if number != nil { // 以前的版本println会自动拆包, 现在的不会 println(number!) } // 如果要将字符串转换为其它类型, 需要借助OC中的方法 str000 = “10.1” var d = (str000 as NSString).doubleValue `]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 函数]]></title>
    <url>%2F2015%2F07%2F08%2FREVIEW%2FSwift_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简介 Swift是Apple在WWDC2014所发布的一门编程语言，用来撰写OS X和iOS应用程序[1]。在设计Swift时．就有意和Objective-C共存，Objective-C是Apple操作系统在导入Swift前使用的编程语言 Swift是供iOS和OS X应用编程的新编程语言，基于C和Objective-C，而却没有C的一些兼容约束。Swift采用了安全的编程模式和添加现代的功能来使得编程更加简单、灵活和有趣。界面则基于广受人民群众爱戴的Cocoa和Cocoa Touch框架，展示了软件开发的新方向。 函数 func1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283println(&quot;[===内部和外部参数===]&quot;);// MARK: 内部和外部参数(加＃)func say(MyName name:String, MyAge age:Int) &#123; println(&quot;hello name=\&quot;\(name)\&quot; &quot;+&quot;\n\n&quot; + &quot; age=\&quot;\(age)\&quot;&quot;)&#125;//say(&quot;mb&quot;, 22)say(MyName: &quot;mb&quot;, MyAge: 22)// 带＃func say(#name:String, #age:Int) &#123; println(&quot;hello \(name) \(age)&quot;)&#125;say(name: &quot;mb&quot;, age: 27) // MARK: 交换 inout （取地址，交换）func swap(inout a: Int, inout b:Int)&#123; var temp = a; a = b; b = temp;&#125;var x = 10;var y = 20;println(&quot;交换前 a=\(x) b=\(y)&quot;);swap(&amp;x, &amp;y);println(&quot;交换后 a=\(x) b=\(y)&quot;);// 交换func swap1(var a:Int, var b:Int)&#123; var temp = a; a = b; b = temp;&#125;var x1 = 10;var y2 = 20;println(&quot;Before exchanging.&quot;+&quot;\n\n&quot;+&quot; a=\(x) b=\(y)&quot;);swap1(x1, y2);println(&quot;After exchanging.&quot;+&quot;\n\n&quot;+&quot; a=\(x) b=\(y)&quot;); // 函数 变参func add(arr:Array&lt;Int&gt;) -&gt; Int&#123; var sum : Int = 0; for i in arr &#123; sum += i; &#125; return sum;&#125;println(add([1, 2, 3])); func add(#a:Int, #arr:Int...) -&gt; Int &#123; var sum:Int = 0; for i in arr &#123; sum += i; &#125; return sum + a;&#125;//println(add(7, [1, 2, 3])); 分享： Swift苹果官方版：|–&gt; Download ［ 每日一句 ］ “ There’s always more to learn, and there are always better ways to do what you’ve done before. “ – Donald Ervin Knuth ［推荐网址］ http://www.cocoachina.com]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods & Alcatraz]]></title>
    <url>%2F2015%2F06%2F06%2FREVIEW%2FCocoaPods_Alcatraz%2F</url>
    <content type="text"><![CDATA[安装CocoaPods 当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。自动集成&amp;管理第三方框架，避免每次都手动集成！ CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。 添加源 1$ sudo gem sources -a http://ruby.taobao.org/ 删除源 1$ sudo gem sources -r https://rubygems.org/ 安装CocoaPods 1$ sudo gem install cocoapods 设置 1$ pod setup 测试 1$ pod —version 查看 1$ gem sources -l 不更新远程仓库 1$ pod update —no-repo-update 导入AFNetworking框架 搜索 123$ pod search AFNetworking$ vi Podfile #写入 安装 1$ pod install 升级 1$ pod update 安装Alcatraz管理Xcode插件［Package Manager］！ Alcatraz only supports Xcode 7. 具体见：https://www.jianshu.com/p/cd75a6e7edf0 远程安装Alcatraz 1$ curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh 查看gem源 1$ gem sources –l gem自身升级 1$ sudo gem update –system 查看版本 1$ gem --version 清除过期的gem 1$ sudo gem cleanup 安装包 1$ sudo gem install cocoapods 删除包 1$ gem uninstall cocoapods 更新包 1$ sudo gem update 列出本地安装的包 1234$ gem list``` * 创建Podfile文件，在其中添加 $ vi Podfile $ echo “pod ‘SDWebImage’, ‘~&gt; 3.7.2’” &gt; Podfile $ pod –version 123456780.36.3 (0.36版本，不支持中文) ---初始化，远程git仓库。 $ git init $ git add . $ git commit -m “ProjectName”`]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git@OSC & SSH配置]]></title>
    <url>%2F2015%2F06%2F01%2FREVIEW%2FGit_OSC_SSH%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[ 导入外部Git仓库到中国源代码托管平台（Git@OSC）]免费代码托管 您可以通过SSH或者HTTP的方式提交和管理代码,也可以通过Web的方式在线阅读,编辑代码与Team@OSC的集成 代码托管与团队协作的一体化服务式管理平台,轻松管理源代码。 方案1： 从原始地址clone一份bare仓库 1$ git clone --bare https://github.com/hannb/test.git 在Git@OSC上创建一个项目（http://git.oschina.net/projects/new）,这里注意，不要勾选使用Readme初始化项目，不要选择项目的授权协议和.gitignore 文件，因为这些会导致项目有第一个提交。 记下新建项目后的地址，推荐使用http或者ssh方式皆可，大项目推荐ssh方式。 1$ cd test 1$ git push --mirror git@git.oschina.net:[username]/test.git 此命令执行完成后即完成导入，删除 test 文件夹即可。 方案2：此方案，手头已经有了项目的完成仓库，则无需再从第三方代码托管平台上clone下来。 到Git@OSC上创建项目，同样不要选择以上所说的三项。 命令行进入项目目录，git status 确保项目状态为： nothing to commit, working directory clean 如果状态不是这样，则需要通过提交、暂存等操作，使项目当前状态为clean。 添加Git@OSC的remote 1$ git remote add git-osc git@git.oschina.net:[username]/test.git 推送所有分支和tags 1$ git push git-osc --all 1$ git push git-osc --tags 以上两条命令执行完毕，即完成导入。 方案3：此方案针对导入已有的SVN仓库 同上，先新建项目，不要选择以上所说的三项 使用git-svn工具clone svn仓库，git-svn 已经是Git的默认组建，如果你安装的是较新版本的Git客户端的话，则不需要再单独下载这个组件 1$ git svn clone http://translate4j.googlecode.com/svn/trunk/ translate4j 同样，进入项目目录，添加remote 1$ git remote add git-osc git@git.oschina.net:[username]/test.git 同样，推送所有分支和标签 1$ git push git-osc --all 1$ git push git-osc --tags 以上两条命令执行完毕，即推送完成 配置SSHSSH 为 Secure Shell 的缩写，安全外壳协议：SSH 为建立在应用层和传输层基础上的安全协议。 （公钥 &amp; 私钥）利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 －－同样，在GitHub上实现过程一样。 1、创建SSH： 1$ ssh-keygen -t rsa -C “test@gmail.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/Trybst/.ssh/id_rsa): git_os_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in git_os_rsa. Your public key has been saved in git_os_rsa.pub. The key fingerprint is: 07:73:91:05:3e:1b:3b:d4:ea:ed:4d:55:50:ae:4a:f8 test@gmail.com The key&apos;s randomart image is: +--[ RSA 2048]----+ | .++oo..o*| | ..+. ...| | o = ... o.| | = = ...| | S * . . | | o o . | | E | | | | | +-----------------+ 2、将公钥添加到剪贴板，再添加(粘贴)到网页中 123$ pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 3、本地验证： 1$ eval &quot;$(ssh-agent -s)&quot; Agent pid 2815 1$ ssh-add ~/.ssh/git_os_rsa Enter passphrase for /Users/Belief/.ssh/git_os_rsa: Identity added: /Users/xxx/.ssh/git_os_rsa (/Users/xxx/.ssh/git_os_rsa) 1$ ssh -T git@git.oschina.net Welcome to Git@OSC, SpongeBob_Han! 4、导入工程： 1$ git clone https://github.com/hannb/test.git ［ 用 $ git clone 仓库HTTPS地址，将其导出到$ cd Desktop桌面！ ］]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook配置]]></title>
    <url>%2F2015%2F05%2F27%2FREVIEW%2FGitBook%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[GitBook 是一个通过 Git 和 Markdown 来撰写书籍的工具。 生成格式有：JSON、ePub、PDF、Website ！ Git 方式 GitBook 使用 Git 进行写作内容管理。 从用户的角度看，这样能够方便地进行多人协作（连程序源代码都能管好，书籍自然不在话下），还不用学习额外概念或用法 从设计实现的角度看，这样能够合理利用已有工具（不重复造轮）满足产品需求，甚至扩展性更好（Git 相关服务能够利用的太多了） Markdown GitBook 不只是利用了 Git，目前非常流行的 Markdown 也被运用其中。 使用 Markdown 最大的好处就是简单： 语法简单，并且能够形象地表达出意图（例如无序列表使用 * ，强调使用 ** ，一个 # 表示 H1、两个 # 表示 H2） 不干扰写作者：语法标记在视觉上对写作者的负面影响不大（不像 HTML 满屏的 &lt;&gt;） 总之，Markdown 就是能够让写作者更专注于内容创作。 不过 GitBook 不只是简单地使用 Markdown，使用 Markdown 编写的内容只是源格式，最终的目标格式可以为 PDF、ePub 等。 ［ 配置方式 ］ 1&gt; 下载并安装 npm node-v0.12.0.pkg http://nodejs.org/download/ 2&gt; 安装 gitbook 1$ sudo npm install gitbook -g 3&gt; 进入终端 cd 到新建的电子书目录 123$ touch SUMMARY.md$ gitbook init 4&gt; 下载并安装 gitbookEditor，gitbook 本地编辑器 https://github.com/GitbookIO/editor/releases 打开并选择刚刚 init 的目录即可编辑 5&gt; 本地预览 1$ gitbook serve 6&gt; 下载并安装 calibre，生成电子书使用 calibre-2.20.0 http://calibre-ebook.com/download_osx 1$ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 7&gt; 生成电子书 12345$ gitbook epub或者$ gitbook pdf 8&gt; .gitignore https://github.com/github/gitignore.git PS： ［ 每日一句 ］ 静，是一种气质，也是一种修养。 ［ 推荐一首英文歌 ］ “ Unforgivable Sinner “ - Lene MarLin]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令操作]]></title>
    <url>%2F2015%2F05%2F21%2FREVIEW%2FLinux%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本命令［ man 查看 ］－－万能命令 1、ls 列出文件 (-al) 2、cd 转换目录 3、mkdir 建立新目录 4、cp 拷贝文件 (-R) 5、rm 删除文件 (-rf) 6、mv 移动文件 7、nano 文本编辑 8、cat 查看文件 9、open 打开文件 10、touch 新建文件 11、chgrp 改变文件所属用户组 12、chown 改变文件所有者 13、chmod 改变权限 (777－［r：4］［w：2］［x：1］［－：0］) 14、grep 模糊 匹配 123$ chmod 777 a.c $ grep -i &quot;ErroR&quot; log.text$ 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 pwd 显示当前目录的路径名 pwd 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142(PID) 12$ ps -A | grep .app$ kill -9 30142 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 选择操作时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir | df| 显示文件系统的总空间和可用空间 | df| | w | 显示当前系统活动的总信息 | w | ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
