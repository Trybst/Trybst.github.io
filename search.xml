<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用资源]]></title>
    <url>%2F2019%2F05%2F25%2FResource%2F</url>
    <content type="text"><![CDATA[推荐书籍 豆瓣读书：https://book.douban.com DEVELOPER: 《Effective Objective-C 2.0》 《图解HTTP》、《图解TCP/IP》、《图解网络硬件》、《图解密码技术》 《大话数据结构》、《大话设计模式》 《iOS应用逆向工程》 《编码-隐匿在计算机软硬件背后的语言》 《Scrum敏捷软件开发》 《数学之美》 FINANCIAL: 《思考，快与慢》 《薛兆丰经济学讲义》 《指数基金投资指南》 《价值投资实战手册》 《聪明的投资者》 《富爸爸穷爸爸》 《小狗钱钱》 OTHERS： 《笑场》 《自控力》 《阿弥陀佛 么么哒》 《反脆弱》 《最合宜的位置》 强烈推荐：《菜根谭》- 明·洪应明 一部论述“修养、人生、处世、出世”的语录集！ 在线工具 iconfont - 矢量图标库! 阿里妈妈MUX倾力打造的矢量图标管理、交流平台！ 在线工具 - 很多很多在线工具集合网站！ 资料查询网站推荐： Segmentfault Github CocoaChina Stackoverflow Gitee 社区论坛推荐： 掘金 CSDN OSChina V2EX 博客园 简书 iOSRE: iOS逆向工程 视频学习网推荐： 慕课网 网易公开课 敏捷开发 Toggle Alfred: [密码:tid0] - 便捷搜索+工作流神器 Go2Shell: 快速从文件夹路径跳转到Terminal终端 XtraFinder: [密码:hhqy] - 让Finder拥有标签式浏览功能 ShadowsocksX-NG-R8: [密码:ko0k] - 科学上网工具！ss账号-个人推荐: MonoCloud 邀请码：5cec0200011c7 Sketch: [密码:r4z1] - 轻量级矢量设计工具，UI设计更简单高效！推荐：学习网站 Photoshop CC 2017: [密码:dwon] - PS制图、设计应用界面 Axure 8.x: [密码:jn9t] -产品原型设计 App Icon Gear: logo生成各个格式 LICEap: 动态gif录制小软件！ Downie: [密码:2i1q] - mini极简网络下载工具 Xmind: 密码:r20y] - 思维导图 小技巧 快捷键：command + shift + .&gt; 显示/隐藏-隐藏文件！ 更多Mac快捷键：https://support.apple.com/zh-cn/HT201236 开发相关 https://www.jetbrains.com/: Whichever technologies you use, there’s a JetBrains tool to match. PostMan - 「Google Chrome 也有插件」网络API测试开发必备神器！ Charles: [密码:ue2r] - 抓API接口 Sublime Text: [密码:9uug] - 代码编辑利器，各种插件基本支持所有语言开发！ MacDown: MarkDown语法编辑器 SourceTree: [密码:dhao] - git图形GUI工具 PyCharm - Python最好的GUI编译器 逆向相关 Reveal: [密码:hd7c] - 分析App层级结构 iFunbox: [密码:8dgf] - 越狱手机文件处理 MachOView: [密码:8n3t] - 分析逻辑代码实现 class-dump: [密码:3j8f] - 分析头文件 如何制作test.dmg镜像文件？ 新建文件夹test，将 *.app 和 Applications替身文件 放到这个文件夹下！ 打开磁盘工具 -&gt; 文件 -&gt; 新建镜像 -&gt; 来自文件夹的镜像，选中文件夹test，存储即可生成！ 声明本站软件全部来自网络，仅供交流学习使用不可私自传播。如作他用所承受的法律责任一概与作者无关。若无意伤害你的权益，请联系将立刻配合处理！ 「下载使用即代表你同意上述观点」]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>奇淫巧技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim - the ubiquitous text edito]]></title>
    <url>%2F2019%2F05%2F20%2Fvim%2F</url>
    <content type="text"><![CDATA[玩转Vim官网：vim.org - 无处不在的文本编辑器 推荐学习： 菜鸟教程：Linux教程 - vi/vim 慕课网（视频）：玩转Vim 从放弃到爱不释手]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《忽而今夏》]]></title>
    <url>%2F2019%2F05%2F09%2Finformal_essay_%E5%BF%BD%E8%80%8C%E4%BB%8A%E5%A4%8F%2F</url>
    <content type="text"><![CDATA[《忽而今夏》 作者：明前雨后 简介：主要讲述“章远”和“何洛”从学校到社会，超过十年的爱情故事。 内容： 这里有许多我们熟悉的画面，纯净得让人嫉妒的青春。在我们最意气风发的青春年华，遇见那个最合适的你！ 在简短少年时代，与她有个不一样的夏天。在追寻的路上，朋友的陪伴，让自己都不相信能坚持到最后的自己。 “你说你搭上半条命都考不上，你真的做到了吗？”（真的坚持了吗？） 在自己青春的路上，拼了命一样努力为目标而奋斗！ （努力做到了，别人认为她完全不可能做到的事情）。 忽然感觉自己的青春都活到了dog身上，一直糊糊涂涂。前半生就这么迷迷糊糊的过去了…… “The best preparation for tomorrow, is doing your best today.”（做今天最好的自己！） 不能总这么简简单单的过，总得为了自己的目标而坚持不懈，证明自己也曾年轻过、疯狂过。平凡的我们至少有努力的资格！ 错的只是那些自以为是的一辈子… 总有一天，我们会成为那个连我们都喜欢的自己！ “想清楚自己想干什么？还有能干什么？”（找到自己的方向!） 这个年纪的我们，总得为了某个心疼的她或他而改变，总得让身边的对自己放心。这样多年后的自己，才不会留下任何遗憾！ …“KNOWLEDGE IS POWER.”… 小傻瓜！青春的尾巴遇见你，真巧！余生有你，真好！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2019%2F05%2F08%2FMarkDown%2F</url>
    <content type="text"><![CDATA[语法教程：http://www.markdown.cn 基本常用用法换行：行尾 加 两个空格 &amp; 回车符. 间隔：每段落写完后 空一整行 or 直接使用标签&lt;br/&gt; 空格：手动&amp;nbsp; or 全角空格(MD只能识别一个空格-在半角输入状态) 段首缩进： &emsp;&emsp;come here…写法为：&amp;emsp;&amp;emsp;come here... 1234半方大的空白 &amp;ensp; 或 &amp;#8194;全方大的空白 &amp;emsp; 或 &amp;#8195;不断行的空白格 &amp;nbsp; 或 &amp;#160;两个 &amp;emsp; 加粗：**Strong** _斜体_：* Emphasize* —下划线—： ---下划线---or&lt;u&gt;下划线&lt;/u&gt; 加粗斜体：***Strong &amp; Emphasize*** 删除线：~~删除线~~ 分割线：***或---或___ 选中标记：&lt;mark&gt;标记&lt;/mark&gt; 转义字符\：So A\*maz\*ing So A*maz*ing 2的n+1次方：2&lt;sup&gt;n&lt;/sup&gt; 2\^(n+1) = 2(n+1) 特殊符号$：一个\$直接显示，两个\$$之间转义为数学公式$$\int_0^1 x^2\,dx$$ $$\int_0^1 x^2\,dx$$ 链接 链接：![图片描述](图片地址/本地地址)&quot;(空格) 鼠标悬停显示文字(可选)&quot; PS: MD语法可与HTML标签共用； 即：&lt;img src=&quot;http://...&quot; width = &quot;100&quot; height = &quot;100&quot; align=right /&gt; 邮箱：&lt;邮箱地址&gt;e-mail: &#x74;&#x72;&#x79;&#x62;&#115;&#116;&#x40;&#x79;&#101;&#x61;&#x68;&#x2e;&#110;&#101;&#x74; 目录 &amp; 代码块 1 * 1 2 * 2 复选框：在无序列表符号后面加上[]或者[x]代表选中或者未选中情况 【注意：这里每行不要有间距，否则会被转义为纯文本】 test test test test 代码： 1. [x] test test test test 代码： * [x] test test test test 代码： * [x] test test test test 代码：2. [ ] 代码块：`$ code 1$ code 表格主要使用：|列，-行，:对齐；（PS：最左边和最右边|只是为了美观，: 作为左右对齐的标志；） 单表格 1234First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell 对齐+多表格 12345| Left Aligned | Center Aligned | Right Aligned ||:------------- |:---------------:| -------------:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 复杂表格： 12345678910Option name | Markup | Result if enabled |--------------------|------------------|-----------------------|Intra-word emphasis | So A\*maz\*ing | So A&lt;em&gt;maz&lt;/em&gt;ing |Strikethrough | \~~Much wow\~~ | &lt;del&gt;Much wow&lt;/del&gt; |Underline [^under] | \_So doge\_ | &lt;u&gt;So doge&lt;/u&gt; |Quote [^quote] | \&quot;Such editor\&quot; | &lt;q&gt;Such editor&lt;/q&gt; |Highlight | \==So good\== | &lt;mark&gt;So good&lt;/mark&gt; |Superscript | hoge\^(fuga) | hoge&lt;sup&gt;fuga&lt;/sup&gt; |Autolink | http://t.co | &lt;http://t.co&gt; |Footnotes | [\^4] and [\^4]: | [^4] and footnote 4 | Option name Markup Result if enabled Intra-word emphasis So A*maz*ing So Amazing Strikethrough ~~Much wow~~ Much wow Underline [^under] _So doge_ So doge Quote [^quote] \”Such editor\” Such editor Highlight \==So good\== So good Superscript hoge\^(fuga) hogefuga Autolink http://t.co http://t.co Footnotes [\^4] and [\^4]: [^4] and footnote 4 其他用法12345---title: &quot;title&quot;tag: &quot;md&quot;date: 2019-5-8--- “x”代表已经选中， “ ”代表未选中。 12341. [x] I can render checkbox list syntax * [ ] I support nesting * [x] I support ordered *and* unordered lists2. [ ] I don&apos;t support clicking checkboxes directly in the html window I can render checkbox list syntax I support nesting I support ordered and unordered lists I don’t support clicking checkboxes directly in the html window 博客地址：https://www.cnblogs.com/SpongeBob-GitHub/]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析iOS应用“追书神器”]]></title>
    <url>%2F2019%2F05%2F06%2Fzhuishushenqi-analyze%2F</url>
    <content type="text"><![CDATA[&gt; 逆向分析应用 UIView的层级结构 （Reveal） 控制器的层级结构（Cycript） API网络接口（Charles） 代码&amp;框架猜想（class-dump、MachOView等） 12345PS:准备条件1. 已越狱的手机设备2. 对逆向需要的那些工具已经准备好（百度&amp;Google很好实现）3. 通过PP助手等，下载“追书神器”旧版本4. 通过iFunBox将ipa文件下载到电脑，找到Mach-O文件 一：class-dump的初步分析头文件 常用格式： class-dump -H Mach-O文件路径 -o 头文件存放目录 1$ class-dump -H ~/Desktop/iOSRE/mach-o/YouShaQi -o ~/Desktop/iOSRE/header/zhuishushenqi 将zhuishushenqi文件夹通过sublime打开，就可以通过.h文件简单分析里面所用到的框架&amp;方法]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向iOS应用的思路]]></title>
    <url>%2F2019%2F05%2F05%2FiOSRE%2F</url>
    <content type="text"><![CDATA[1.界面分析 [Cycript、Reveal]2.代码分析 [MachOView、class-dump、Hopper Disassembler、ida等]3.动态调试 [对运行中的APP进行代码调试(debugserver、LLDB)]4.代码编写 [注入代码到APP中 必要时还可能需要重新签名、打包ipa] PS: Reveal-&gt;识别 UIView 的层级结构 1. 去下载Reveal4.0以上版本（支持USB调试），并破解（网上有教程） 2. 调试环境配置 2.1 软件源：http://apt.so/codermjlee 2.2 安装完Reveal Loader后，打开手机【设置】，找到Reveal-&gt;Enabled Applications-&gt;选择需要调试的APP 2.3 找到Mac的Reveal中的RevealServer文件，并覆盖iPhone中的/Library/RHRevealLoader/RevealServer文件 2.3.1 Reveal导航栏中Help -&gt; Show Reveal Library in Finder -&gt; iOS Library 2.3.2 重启手机：reboot 3.0 这下打开手机&amp;Reveal就可以实时看到APP的结构 PS：Cycript-&gt;识别 控制器 的层级结构推荐Mj的一个开源库mjcript ting是应用的进程名 1~ root# cycript -p ting 进入cy环境（cmd+r清屏==clear，） 1234cy# @import mjcript&#123;&#125;cy# MJChildVcs(MJRootVc())&#123;&#125;]]></content>
      <categories>
        <category>iOS逆向</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles]]></title>
    <url>%2F2019%2F01%2F14%2FCharles%2F</url>
    <content type="text"><![CDATA[简介： 是在Mac下常用的截取网络封包的工具，在做iOS开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles主要的功能包括： 支持SSL代理。可以截取分析SSL的请求。 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。 支持AJAX调试。可以自动将json或xml数据格式化，方便查看。 支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 检查HTML，CSS和RSS内容是否符合W3C标准。 安装Charles： 1、官方网站（http://www.charlesproxy.com）下载最新版的Charles安装包； 2、如需要截取分析SSL协议相关的内容。那么需要安装Charles的CA证书。具体步骤如下： 去 http://www.charlesproxy.com/ssl.zip 下载CA证书文件。 解压该zip文件后，双击其中的.crt文件，这时候在弹出的菜单中选择“总是信任” 3、Charles封包的视图：“Structure” &amp; “Sequence” Structure视图将网络请求按访问的域名分类。 Sequence视图将网络请求按访问的时间排序。 总结： 1、下载Charles抓包工具(iOS)：－－已经破解，可直接使用！ 下载地址：http://yun.baidu.com/s/1GvxaY 2、截取iPhone上的网络封包： 《－－－－－－Main 1.［Clarles设置］将Charles的代理功能打开。在Charles的菜单栏上选择 “Proxy”-&gt;”Proxy Settings” 填入代理端口8888，并且勾上&quot;Enable transparent HTTP proxying&quot; 就完成了在Charles上的设置。 2.［iPhone设置］将获取到的电脑IP地址(终端$ifconfig en0–查看网卡en0的IP地址)，在iPhone手机同一局域网下，设置HTTP代理协议 填入电脑的IP，并且写入端口8888。 3、截取SSL信息： Charles默认并不截取SSL的信息，如果你想对截取某个网站上的所有SSL网络请求，可以在该请求上右击，选择SSL proxy。 4、模拟慢速网络获取数据： 原因：在做iPhone开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。 1 TODO：在Charles的菜单，选择&quot;Proxy&quot;-&gt;&quot;Throttle Setting&quot;项，勾选上“Enable Throttling”，并且可以设置Throttle Preset的类型。 5、修改网络请求内容： 有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。 Charles提供：“网络请求的修改”和“重发”功能。只需要在以往的网络请求上点击右键，选择“Edit”，即可创建一个可编辑的网络请求。 PS：我们可以修改该请求的任何信息，包括url地址，端口，参数等，之后点击“Execute”即可发送该修改后的网络请求（如下图所示）。 Charles支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便。 6、过滤网络请求《－－－－Main 1234567通常情况下，我们需要对网络请求进行过滤，只监控向指定目录服务器上发送的请求。对于这种需求，我们有2种办法。在主界面的中部的Filter栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://www.baidu.com，那么只需要在Filter栏中填入baidu即可。在Charles的菜单栏选择&quot;Proxy&quot;-&gt;&quot;Recording Settings&quot;，然后选择Include栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了 TODO：［“Proxy”－&gt;“Recording Setting”－&gt;“Include”－&gt;“Add”－&gt;填写内容：http, baidu.com, 80］ “网易新闻”－－数据拦截： 12345678910111213141516171819202122232425262728293031/*［ c.m.163.com/nc/article/headline/T1348647853363/0-100.html ］*/- (void)loadData &#123; NSURL *url = [NSURL URLWithString:@&quot;http://c.m.163.com/nc/article/headline/T1348647853363/0-20.html&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:0 error:NULL];// NSLog(@&quot;%@&quot;, dict); // 拿到字典中第一项的数组 // 使用 keyEnumerator.nextObject 可以快速遍历字典的键值 NSLog(@&quot;%@&quot;, dict.keyEnumerator.nextObject); // 取字典键值的小技巧，对于网易新闻，可以直接过滤掉第一层字典 NSArray *array = dict[dict.keyEnumerator.nextObject]; NSLog(@&quot;%@&quot;, array); // 遍历数组，字典转模型 NSMutableArray *arrayM = [NSMutableArray arrayWithCapacity:array.count]; [array enumerateObjectsUsingBlock:^(NSDictionary *dict, NSUInteger idx, BOOL *stop) &#123; News *news = [News newsWithDict:dict]; [arrayM addObject:news]; NSLog(@&quot;%@&quot;, news.objectInfo); &#125;]; &#125;];&#125;]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序 & 快速排序]]></title>
    <url>%2F2018%2F06%2F15%2FREVIEW%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序简介： 归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为： 比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1； 否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。 归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 归并排序代码实现：123456789101112131415// [ Merge Sort ]// mergeSort.h:#include &lt;assert.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void merge (int a[], int b[], int c[], int m, int n);void mergesort (int key[], int n);void wrt (int key[], int sz); 12345678910111213141516171819202122232425262728293031323334353637// merge.c:/* Merge a[] of size m and b[] of size n into c[]. */#include &quot;mergesort.h&quot;void merge (int a[], int b[], int c[], int m, int n)&#123; int i = 0, j = 0, k = 0; ; while (i &lt; m &amp;&amp; j &lt; n) if (a[i] &lt; b[j]) c[k++] = a[i++]; else c[k++] = b[j++]; ; while (i &lt; m) /* pick up any remainder */ c[k++] = a[i++]; ; while (j &lt; n) c[k++] = b[j++];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// mergesort.c:/* Mergesort: Use merge() to sort an array of size n. */#include &quot;mergesort.h&quot;void mergesort (int key[], int n)&#123; int j, k, m, *w; for (m = 1; m &lt; n; m *= 2) ; /* m is a power of 2 */ if (n &lt; m) &#123; printf(&quot;ERROR: Array size not a power of 2 - bye! \n&quot;); exit(1); &#125; w = calloc (n, sizeof(int)); /* allocate workspace */ assert(w != NULL); /* check that calloc() worked */ for (k = 1; k &lt; n; k *=2) &#123; for (j = 0; j &lt; n-k; j += 2*k) /* Merge two subarrays of key[] into a subarray of w[]. */ merge(key + j, key+j+k, w+j, k, k) for (j = 0; j &lt; n; ++j) key[j] = w[j]; /* write w back into key */ &#125; free(w); /* free the workspace */&#125; 12345678910111213141516171819202122232425262728293031// main.c:/* Test merge() and mergesort(). */#include &quot;mergesort.h&quot;int main(void)&#123; int sz, key[] = &#123; 4, 3, 1, 67, 55, 8, 0, 4, -5, 37, 7, 4, 2, 9, 1, -1 &#125;; sz = sizeof(key) / sizeof(int); /* the size of key[] */ printf(&quot;Before mergesort:\n&quot;); wrt(key, sz); mergesort(key, sz); printf(&quot;After mergesort:\n&quot;); wrt(key, sz); return 0;&#125; 12345678910111213141516// wrt.c:#include &quot;mergesort.h&quot;void wrt(int key[], int sz)&#123; int i; for (i = 0; i &lt; sz; ++i) printf(&quot;%4d %s&quot;, key[i], ((i &lt; sz-1) ? &quot; &quot; : &quot;\n&quot;));&#125; 快速排序简介： 快速排序（Quicksort）是对冒泡排序的一种改进。 基本思想：－－二分查找 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序图 1.设要排序的数组是A[0]……A[N-1]。首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。 2.快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 快速排序代码实现：1234567891011121314151617// Quick Sort/* Quicksort! Pointer version with macros. */#define swap(x, y) &#123;int t; t = x; x = y; y = t;&#125;#define order(x, y) if (x &gt; y) swap(x, y)#define o2(x, y) order(x, y)#define o3(x, y, z) o2(x, y); o2(x, z); ow(y, z)#typedef enum &#123;yes, no&#125; yes_no;static yes_no find_pivot(int *left, int *right, int *pivot_ptr);static int *partition(int *left, int *right, int pivot); 12345678910111213141516171819//利用“递归”实现，基本思路：“分治法” quicksort(a, a+N-1);void quicksort(int *left, int *right)&#123; int *p, pivot; if (find_pivot(left, right, &amp;pivot) == yes) &#123; p = partition(left, right, pivot); quicksort(left, p-1); quicksort(p, right); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static yes_no find_pivot(int *left, int *right, int *pivot_ptr)&#123; int a, b, c, *p; a = *left; /* left value */ b = *(left + (right - left) / 2); /* middle value */ c = *right; ; o3(a, b, c); if (a &lt; b) &#123; *pivot_ptr = b; return yes; &#125; if (b &lt; c) &#123; *pivot_ptr = c; return yes; &#125; ; for (p = left+1; p &lt;= right; ++p) if (*p != *left) &#123; *pivot_ptr = (*p &lt; *left) ? *left : *p; return yes; &#125; return no; /* all elements have the same value */&#125; 12345678910111213141516171819202122232425262728293031// 主要工作由partation()函数完成static int *partation(int *left, int *right, int pivot)&#123; while (left &lt;= right) &#123; while (*left &lt; pivot) ++left; while (*right &gt;= pivot) --right; if (left &lt; right) &#123; swap(*left, *right); ++left; --right; &#125; &#125; return left;&#125; ex: 使用“快速”排序，高效率，复杂度：n log n 总结： 递归算法一般用于解决三类问题： (1)数据的定义是按递归定义的。（Fibonacci函数） (2)问题解法按递归算法实现。这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。 (3)数据的结构形式是按递归定义的。如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。 递归的缺点： 递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。 递归典型问题： 梵塔问题（汉诺塔问题） 已知有三根针分别用A, B, C表示，在A中从上到下依次放n个从小到大的盘子，现要求把所有的盘子 从A针全部移到B针，移动规则是：可以使用C临时存放盘子，每次只能移动一块盘子，而且每根针上不能出现大盘压小盘，找出移动次数最小的方案. ［ 每日一句 ］ There’s a plan to make all of this right. ［ 每天一首英文歌 ］ “ Call me maybe “ - Carly Rae Jepsen]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（图解）]]></title>
    <url>%2F2018%2F05%2F24%2FREVIEW%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[算法一：快速排序算法简介： 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 算法步骤： 1 从数列中挑出一个元素，称为 “基准”（pivot）， 2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 [递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。] 算法二：堆排序算法简介： 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序的平均时间复杂度为Ο(nlogn) 。 算法步骤： 1.创建一个堆H[0..n-1] 2.把堆首（最大值）和堆尾互换 3.把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置 4.重复步骤2，直到堆的尺寸为1 算法三：归并排序简介： 归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 算法步骤： 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 2.设定两个指针，最初位置分别为两个已经排序序列的起始位置 3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 4.重复步骤3直到某一指针达到序列尾 5.将另一序列剩下的所有元素直接复制到合并序列尾 算法四：二分查找算法简介： 二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。 算法五：BFPRT(线性查找算法)简介： BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。 算法步骤： 将n个元素每5个一组，分成n/5(上界)组。 取出每一组的中位数，任意排序方法，比如插入排序。 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。 若i==k，返回x；若i&lt;k，在小于x的元素中递归查找第i小的元素；若i&gt;k，在大于x的元素中递归查找第i-k小的元素。 终止条件：n=1时，返回的即是i小元素。 算法六：DFS（深度优先搜索）简介： 深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发 现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。 深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。 深度优先遍历图算法步骤： 访问顶点v； 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问； 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。 上述描述可能比较抽象，举个实例： DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。 算法七：BFS(广度优先搜索)简介： 广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。 算法步骤： 1.首先将根节点放入队列中。 2.从队列中取出第一个节点，并检验它是否为目标。 如果找到目标，则结束搜寻并回传结果。 否则将它所有尚未检验过的直接子节点加入队列中。 3.若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。 4.重复步骤2。 算法八：Dijkstra算法简介： 戴克斯特拉算法（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。 算法步骤： 1.初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值 若存在&lt;V0,Vi&gt;，d(V0,Vi)为&lt;V0,Vi&gt;弧上的权值 若不存在&lt;V0,Vi&gt;，d(V0,Vi)为∞ 2.从T中选取一个其距离值为最小的顶点W且不在S中，加入S 3.对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值 重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止 算法九：动态规划算法简介： 动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多 子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个 子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 关于动态规划最经典的问题当属背包问题。 算法步骤： 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。 动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是 在表格中简单地查看一下结果，从而获得较高的效率。 算法十：朴素贝叶斯分类算法简介： 朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下， 如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。 朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。 尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈 & 堆 |--> 内存管理]]></title>
    <url>%2F2018%2F04%2F23%2FREVIEW%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[内存管理： 栈区 [stack]：由编译器自动分配并释放，一般存放函数的参数值，局部变量等 堆区 [heap]：由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 全局区(静态区) [static]：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放 文字常量区：存放常量字符串，程序结束后由系统释放 程序代码区：存放函数的二进制代码 官方文档： 在iOS开发中：一. 内存分析 静态分析(Analyze) 不运行程序, 直接检测代码中是否有潜在的内存问题(不一定百分百准确, 仅仅是提供建议) 结合实际情况来分析, 是否真的有内存问题 动态分析(Profile == Instruments) 1&gt; 运行程序, 通过使用app, 查看内存的分配情况(Allocations) 可以查看做出了某个操作后(比如点击了某个按钮\显示了某个控制器), 内存是否有暴增的情况(突然变化) 2&gt; 运行程序, 通过使用app, 查看是否有内存泄漏(Leaks) 红色区域代表内存泄漏出现的地方 二. 内存使用注意 加载小图片\使用频率比较高的图片 1&gt; 利用imageNamed:方法加载过的图片, 永远有缓存, 这个缓存是由系统管理的, 无法通过代码销毁缓存 加载大图片\使用频率比较低的图片(一次性的图片, 比如版本新特性的图片) 1&gt; 利用initWithContentsOfFile:\imageWithContentsOfFile:\imageWithData:等方法加载过的图片, 没有缓存, 只要用完了, 就会自动销毁 2&gt; 基本上, 除imageNamed:方法以外, 其他加载图片的方式, 都没有缓存 PS：－－关于图片资源 1&gt; 会压缩到Assets.car文件, 没有直接暴露在沙盒的资源包(main Bundle) 条件 : “Deployment Target &gt;= 7.x” 并且是 “放在Images.xcassets里面的所有图片” 影响 : 无法得到图片的全路径, 只能通过图片名(imageNamed:方法)来加载图片, 永远会有缓存 2&gt; 不会压缩到Assets.car文件, 直接暴露在沙盒的资源包(main Bundle) 条件 : 除1&gt; 以外的所有情况 影响 : 可以得到图片的全路径, 可以通过全路径(imageWithContentsOfFile:方法)来加载图片, 不会有缓存 三. 如何让程序尽量减少内存泄漏 非ARC－－MRC Foundation对象(OC对象) : 只要方法中包含了alloc\new\copy\mutableCopy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次release或者1次autorelease CoreFoundation对象(C对象) : 只要函数中包含了create\new\copy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次CFRelease或者其他release函数 ARC(只自动管理OC对象, 不会自动管理C语言对象) CoreFoundation对象(C对象) : 只要函数中包含了create\new\copy\retain等关键字, 那么这些方法产生的对象, 就必须在不再使用的时候调用1次CFRelease或者其他release函数 利用__bridge桥接，告诉编译器 管理c语言对象。 block的注意－－见：block详解！ 1234567891011121314151617// block的内存默认在栈里面(系统自动管理)void (^test)() = ^&#123;&#125;; // 如果对block进行了Copy操作, block的内存会迁移到堆里面(需要通过代码管理内存)Block_copy(test); // 在不需要使用block的时候, 应该做1次release操作Block_release(test);[test release]; 栈区 栈：由系统自动分配 –由系统自动分配，速度较快 [ FIFO ] 栈区结构：链表 or 数组 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域，栈顶的地址和栈的最大容量是系统预先规定好的，在 iOS中，主线程栈的大小是1M －－［ 栈区：申请内存后响应 ］ 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 －－存储的内容 栈：变量名(不带*)相当于是指向栈区数据的指针别名，变量名可以简化程序员的工作 堆区 堆：需要程序员自己申请，alloc，copy –是由alloc分配的内存，速度比较慢，而且容易产生内存碎片，不过用起来最方便 [ LIFO ] 堆区结构：树 or 链表 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大 －－［ 堆区：申请内存后响应 ］ 堆： 操作系统有一个记录空闲内存地址的链表 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 －－存储的内容 堆：要访问堆区中的数据，必须通过指针的方式才可以进行，指针的类型决定了访问堆中数据的方式 －－堆区的操作！ 1、操作系统以匿名(只记录内存地址和大小，不记录具体类型)的方式记录已经分配的内存区域 2、当某一内存区域不再使用时，程序需要通知操作系统回收该内存区域，从而可以保证该内存区域被其他程序再次使用，否则，该区域将永远无法被再次分配，这就是传说中的“内存泄露” 3、如果某一区域已经被释放，仍然视图访问该区域，会提示“坏内存访问”，这就是传说中的“野指针访问” 总结： 1、我们程序员只需要关心堆区的内存管理，而栈区系统会自动回收。 2、栈区存放的局部变量，出了作用域就会被销毁！ 3、内存结构中的其他几个分区，跟程序同生死：程序启动时，被加载到内存中；程序摧毁，内存被回收！ PS：在iOS开发中： 1&gt; 堆区的内存是所有应用程序共享的，问题：内存泄露 &amp; 野指针 |–&gt; 内存泄漏：如果程序员使用变量后，不释放内存(有强指针指向它)，该内存区域会永远被占有，别的Application无法使用，即内存警告 |–&gt; 内存溢出(Out Of Memory)：内存不够使用了，数据长度比较小的数据类型 存储了 数据长度比较大的数据类型 |–&gt; 野指针：当对象已经释放，程序中变量的指针，依然指向该内存地址，如果再向该对象发送消息，就会报“野指针”错误 2&gt; 堆区的内存分配是由系统负责的。 3&gt; 系统是使用一个链表来维护所有已经分配过的内存空间。（见：上边－－堆区：申请内存后响应） 4&gt; 系统只是记录分配了多少字节给应用程序，并不管理具体的类型–&gt;“匿名”：只是记录分配的内存大小，不管具体是哪个类的！ 5&gt; 如果变量使用结束后，需要释放内存，OC中当一个变量的引用计数==0时，说明没有变量使用这块内存空间，即系统直接回收。]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods建立私有仓库]]></title>
    <url>%2F2018%2F03%2F18%2FREVIEW%2FCocoaPods%E5%BB%BA%E7%AB%8B%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[简介 CocoaPods是iOS，Mac下优秀的第三方包管理工具，类似于java的maven，给我们项目管理带来了极大的方便。 ［个人或公司在开发过程中，会积累很多可以复用的代码包，有些我们不想开源，又想像开源库一样在CocoaPods中管理它们，那么通过私有仓库来管理就很必要。］ 对于CocoaPods还不太熟悉的，建议参考一下唐巧的博客或者直接到CocoaPods的官网看看：https://cocoapods.org/ CocoaPods默认只能管理基于git管理的代码，如果要使用svn或者mercurial管理代码，则需要安装一些插件 1.创建代码仓库 将自己写的代码推送到git服务器。如果代码可以开源的话，可以用github来托管。参考我们所开源的代码 2.给稳定的代码打上版本tag，一般以版本号作为tag名 1$ git tag -a 将tag推送到git服务器 1$ git push --tags 这里一般是类似1.0.2的版本号。版本号的规范参考这里 3.创建spec文件 1$ pod spec create 会在当前目录创建.podspec文件，创建的文件是个完整的配置模板，根据字面意思以及注释，大体上都能弄明白。不清楚的地方可以到https://guides.cocoapods.org/making/specs-and-specs-repo.html看看，github上也有很多开源代码可以参考。 4.验证spec文件有效性 1$ pod spec lint .podspec 根据输出提示修改你的spec文件或者代码，直到能pass. 5.创建spec repository（spec 仓库） 除了上面创建的代码仓库，还需要创建一个spec仓库，存放spec，目录结构应该遵照以下的规范： 123456789[plain] view plaincopy├── Specs └── [SPEC_NAME] └── [VERSION] └── [SPEC_NAME].podspec 例： 1234567891011121314151617181920212223242526272829├─Specs ├──QueryKit/ ├── 0.8.0 │ └── QueryKit.podspec ├── 0.8.1 │ └── QueryKit.podspec ├── 0.8.2 │ └── QueryKit.podspec └── 0.8.3 └── QueryKit.podspec URITemplate ├── 1.0.0 │ └── URITemplate.podspec └── 1.0.1 └── URITemplate.podspec 这里的版本号要和代码仓库里的tag一一对应。 将其推送到git服务器，参考我们开源的代码 6.添加私有repo到CocoaPods中 1234$ pod repo add REPO_NAME SOURCE_URL``` * 7.验证私有repo安装无误： $ cd ~/.cocoapods/repos/REPO_NAME $ pod repo lint .12后面如果还要往REPO_NAME里添加新包，只需运行下面命令: $ pod repo push REPO_NAME SPEC_NAME.podspec12如要删除私有repo： $ pod repo remove [name]12* 8.添加包到工程的Podfile中如下： source ‘https://github.com/agdsdl/Specs.git&#39; source ‘https://github.com/CocoaPods/Specs.git&#39; platform :ios, “7.0” target “XXX” do pod ‘DLSlideView’,’~&gt;0.8.1’ end1234567* 9. That&apos;s it! 接下来测试运行： 到工程目录下运行 $ pod update` 依赖包更新完毕后，打开workspace文件，点击Go！ 一些坑: 1、很容易把spec repository和代码repository弄混，我一开始就在这里挂起了好久。代码repository是代码仓库，我们把包代码上传到这个仓库。 2、spec repository是配置仓库，所有的配置按照包名、版本号分门别类的存放在这个仓库。这个仓库只用来存放spec文件，不存放代码。、 3、spec repository可以放在本地，不用git服务器，但是貌似必须用git init初始化这个目录。 详细的一些东西可以看这：https://github.com/CocoaPods/CocoaPods/issues/3041 PS：1到8步都只需在本机执行一次，团队里的其他人只需更新Podfile就可以直接使用私有仓库了。]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译 & 预处理]]></title>
    <url>%2F2017%2F10%2F19%2FREVIEW%2F%E7%BC%96%E8%AF%91_%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[编译(compilation , compile) 1、利用编译程序从源语言编写的源程序产生目标程序的过程。 2、用编译程序产生目标程序的动作。 编译就是把高级语言变成计算机可以识别的2进制语言，计算机只认识1和0，编译程序把人们熟悉的语言换成2进制的。 编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。 预处理(pre-treatment) 定义：指在进行最后加工完善以前进行的准备过程，具体应用在不同的行业或领域，会有不同的解释。 预处理中会展开以#起始的行，试图解释为预处理指令(preprocessing directive) C/C++要求支持的包括#if/#ifdef/#ifndef/#else/#elif/#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）。预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。 1、使用#error和#pragma123456789101112---&gt; 使用#error#if A_SIZE &lt; B_SIZE #error &quot;Incompatible sizes&quot;#endif---&gt; 使用#pragma#pragma tokens 2、预处理指令12345678910111213141516171819202122232425262728293031---&gt; 条件编译#if constant_integral_expression#ifdef identifier#endif identifier/*****************/#undef identifier/*****************/#if 0 more statements#endif and still more statements/*****************/// 等于else if（if－else结构）#elif constant_integral_expression#else ...#endif ... 自定义NSLog ex 1: // 有DEBUG这个宏，代表需要显示Log；没有时，不需要显示Log。 12345678910#ifdef DEBUG#define MBLog(...) NSLog(__VA_ARGS__)#else#define MBLog(...)#endif ex 2: 1234567#defind DEBUG 1#if DEBUG printf (&quot;debug: a = %d \n&quot;, a);#endif ex 3: 123#undef PIE#define PIE &quot;I like apple.&quot; “#” 和 “##” 的使用 // “#”操作符，使参数被一对‘双引号’所包围！ // “#”使宏定义中的一个形式参数“字符串化” －－&gt; 相当于函数“传值” 123456789101112131415161718192021222324#define message_for(a, b) \ printf(#a &quot; and &quot; #b &quot;: We love you! \n&quot;)int main(void)&#123; message_for(Carole, Debra); return 0;&#125;int main(void)&#123; printf(&quot;Carole&quot; &quot; and &quot; &quot;Debra&quot; &quot;: We love you! \n&quot;); return 0;&#125;// &quot; &quot;被空格连接，自动拼接上去，即：Carole and Debra: We love you! 12345678910111213141516171819// 双目操作符&quot;##&quot;，用于合并标记#define X(i) x ## iX(1) = X(2) = X(3);// 预处理后x1 = x2 = x3;导入系统中的命令行“clear”int system(const char * string);int main()&#123; system(&quot;clear&quot;); return 0;&#125; 3、注释使用 #error、#program、#wrong 123456#if A_SIZE &lt; B_SIZE #error &quot;Incompatible sizes&quot;#endif 123#program marks - &quot;Messages.&quot; 将方法分开（中间一根线）#program mark &quot;Messages.&quot; 未分，只为了方便查找 1234567891011121314151617181920212223242526272829303132#wrong &quot;Messages.&quot;``` #### 各种注释方式* 0 |--&gt; iOS编码中 &lt;--|* 1、 /// 和 /*...*/ 都是文件注释Swift中注释：* 2、 // MARK: 注释* 3、 // TODO: 子注释* 4、 // FIXME: 提示修改* 5、 // !!!: 提示* 6、 // ???: 提示* 7、|--&gt; 网页编码中 &lt;--| * 7.1 注释标签用于在源文档中插入注释，注释会被浏览器忽略 .&lt;!-- .#info { . &quot;Message.&quot; .} .--&gt; 1* 7.2 比较 .&lt;!-- comment 会包含在最终生成的html文件中 --&gt; .&lt;%-- comment 则不会包含 --%&gt; . . ``` 8、|–&gt; Terminal脚步编码 &lt;–| 8.1 # Unix风格单行注释 8.2 “ 终端配置时，注释 ［ 每日一句 ］ 人生有两条路，一条需要用心走，叫做梦想；一条需要用脚走，叫做现实。 ［ 每天一首英文歌 ］ “ Roar “ - Katy Perry]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat]]></title>
    <url>%2F2017%2F10%2F18%2FREVIEW%2FTomcat%2F</url>
    <content type="text"><![CDATA[配置步骤： 1、 下载tomcat版本（tar.gz） 到 apache官方主页 下载 Mac 版本的完整 tar.gz文件包。（问公司后台，是Tomcat 6.0/7.0/8.0版本？） 解压拷贝到 /Library目录下,并命名为Tomcat，其他目录也可(但脚本文件中也要修改此目录)。 2、修改目录权限 1$ sudo chmod 755 /Library/Tomcat/bin/*.sh 3、启动Tomcat 12$ cd /Library/Tomcat/bin/$ sudo sh startup.sh 安装并运行成功，提示如下： 1234Using CATALINA_BASE: /Library/Tomcat Using CATALINA_HOME: /Library/Tomcat Using CATALINA_TMPDIR: /Library/Tomcat/temp Using JRE_HOME: /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home 4、 打开浏览器，输入 http://localhost:8080/ 回车之后如果看到Apache Tomcat，表示已经成功运行Tomcat 5、配置Tomcat启动脚本： $ cd /usr/bin 目录 $ sudo touch tomcat $ sudo chmod 777 tomcat $ vi tomcat 然后直接将下边代码复制进去！ tomcat脚本内容12345678910111213141516171819#!/bin/bashcase $1 instart)sh /Library/Tomcat/bin/startup.sh;;stop)sh /Library/Tomcat/bin/shutdown.sh;;restart)sh /Library/Tomcat/bin/shutdown.shsh /Library/Tomcat/bin/startup.sh;;*)echo “Usage: start|stop|restart”;;esacexit 0 快捷命令如下：123451） tomcat start 2) tomcat stop3) tomcat restart]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ikbc G-87 & karabiner]]></title>
    <url>%2F2017%2F09%2F28%2FREVIEW%2Fikbc%2F</url>
    <content type="text"><![CDATA[前言 硬件：MacBook（电脑） + ikbc G-87（键盘） 简述：G-87是ikbc专门为兼容mac出的机械键盘，兼容mac和windows系统 Mac模式 切换 G-87 默认是 windows 模式； 按住Fn+Pause键，切换到mac模式（Pause灯会常亮，再次按下Fn+Esc关闭常亮灯）； 再次按一下Pause键，就可以回到windows模式； mac 模式下：F1、F2、F3 默认正常使用 F4（Launchpad键默认无法使用） 需要设置：”System Preferences -&gt; Keyboard -&gt; Shortcuts ==&gt; Launchpad &amp; Dock ==&gt; Show Launchpad （绑定F4键即可） “ Fn+Pause：双系统模式切换 Fn+End：记忆当前使用模式 Fn+Esc：退出设置&amp;常亮灯关闭 Caps键 改为 Ctrl键 问题：使用 mac 自带的改键映射后，F3、F4无效果 推荐：ikbc支持改键的键盘是 Poker 系列的（有钱的话可以买HHKB，一般人会认为手感不好，慎入手！） 改键神器：karabiner Karabiner-Elements 打造 Vim 风格 - 让键盘变成你想要的样子：改键利器 Karabiner-Elements，直接使用软件功能也行。 「&emsp;&emsp; –&gt; karabiner 图形界面可以直接简单设置键位！！」 方法：使用 karabiner 软件，使用 complex_modifications rules 一、参考：https://github.com/pqrs-org/KE-complex_modifications 二、修改目录&amp;内容 1.路径 12345|--- ~/.config |--- karabiner |--- assets |--- complex_modifications |--- 1510932793.json 2.内容:找到这条规则，将最后的 escape 改为 caps_lock 1234567891011121314151617181920212223242526&#123;&quot;description&quot;: &quot;Change caps_lock to control if pressed with other keys, to escape if pressed alone.&quot;,&quot;manipulators&quot;: [ &#123; &quot;type&quot;: &quot;basic&quot;, &quot;from&quot;: &#123; &quot;key_code&quot;: &quot;caps_lock&quot;, &quot;modifiers&quot;: &#123; &quot;optional&quot;: [ &quot;any&quot; ] &#125; &#125;, &quot;to&quot;: [ &#123; &quot;key_code&quot;: &quot;left_control&quot; &#125; ], &quot;to_if_alone&quot;: [ &#123; &quot;key_code&quot;: &quot;caps_lock&quot; &#125; ] &#125;]&#125; 三、修改目录&amp;内容 1.路径 123|--- ~/.config |--- karabiner |--- karabiner.json 2.内容：找到这条规则，将最后的 escape 改为 caps_lock 12345678910111213141516171819202122232425262728&quot;rules&quot;: [ &#123; &quot;description&quot;: &quot;Change caps_lock to control if pressed with other keys, to escape if pressed alone.&quot;, &quot;manipulators&quot;: [ &#123; &quot;from&quot;: &#123; &quot;key_code&quot;: &quot;caps_lock&quot;, &quot;modifiers&quot;: &#123; &quot;optional&quot;: [ &quot;any&quot; ] &#125; &#125;, &quot;to&quot;: [ &#123; &quot;key_code&quot;: &quot;left_control&quot; &#125; ], &quot;to_if_alone&quot;: [ &#123; &quot;key_code&quot;: &quot;caps_lock&quot; &#125; ], &quot;type&quot;: &quot;basic&quot; &#125; ] &#125; ]]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache & WebDav（二）]]></title>
    <url>%2F2017%2F08%2F24%2FREVIEW%2FApache_WebDav_2%2F</url>
    <content type="text"><![CDATA[WebDav配置 &amp; put脚本编辑！WebDav 配置 修改了两个配置文件 创建web访问用户的用户名和口令 创建了两个目录，并且设置了管理权限 12345# 切换目录$ cd /etc/apache2$ sudo vim httpd.conf 12345# 查找httpd-dav.conf/httpd-dav.conf&quot;删除行首#&quot; 123# 将光标定位到行首0 123# 删除行首的注释x 1234567# 打开这三行LoadModule dav_module libexec/apache2/mod_dav.soLoadModule dav_fs_module libexec/apache2/mod_dav_fs.soLoadModule auth_digest_module libexec/apache2/mod_auth_digest.so 123# 保存退出:wq 12345# 切换目录$ cd /etc/apache2/extra``` 备份文件（只要备份一次就行）$ sudo cp httpd-dav.conf httpd-dav.conf.bak1 编辑配置文件$ sudo vim httpd-dav.conf “将Digest修改为Basic”1 查找Digest/Digest1 进入编辑模式i 1234```# 返回到命令行模式ESC 123# 保存退出:wq 123# 切换目录，可以使用鼠标拖拽的方式$ cd 保存put脚本的目录 12345678910111213# 以管理员权限运行put配置脚本$ sudo ./put``` 设置两次密码: 123456 ## put脚本编辑--- 创建put脚本$ vi put 12* 1、输入脚本内容！ 1 # 切换目录 2 echo “切换至/usr目录” 3 cd /usr 4 # 设置用户admin的密码 5 echo “设置admin的密码” 6 htpasswd -c /usr/user.passwd admin 7 # 设置密码文件的访问群组 8 echo “正在创建相关目录并修改访问权限…” 9 chgrp www /usr/user.passwd10 # 建立var文件夹，保存DavLockDB相关文件11 mkdir -p /usr/var12 # 修改var文件夹用户群组13 chown -R www:www /usr/var14 # 建立上传文件夹：uploads15 mkdir -p /usr/uploads16 # 修改uploads文件夹用户群组17 chown -R www:www /usr/uploads18 echo “修改完毕，请确认…”19 ls -lG20 echo “重新启动Apache服务器”21 # 重新启动Apache 22 apachectl -k restart12* 2、保存并退出 $ :x “退出编辑模式后、用：x12 * 3、修改权限 $ chmod 744 put` ［ 每日一句 ］ “ Many of the improvements I introduced when developing C simply looked like a good thing to do. “ – Dennis Ritchie ［ 每天一首英文歌 ］ “ My Bloody Valentine “ – Tata Young]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache & WebDav（一）]]></title>
    <url>%2F2017%2F08%2F23%2FREVIEW%2FApache_WebDav_1%2F</url>
    <content type="text"><![CDATA[简单Apache服务器的搭建！ 用于文件de上传、下载、修改、删除！ Apache 1.使用最广的 Web 服务器、支持各种脚本(PHP)的执行 2.Mac自带，只需要修改几个配置就可以，简单，快捷 3.有些特殊的服务器功能，Apache都能很好的支持 例如：HTTP PUT/DELETE 操作，知识补充涉及的 HTTPS 服务 WebDav 基于 http 协议的 “文件”服务器 实现文件的上传／下载／修改／删除 FTP 文件传输协议，基于 FTP 的一个文件管理服务器 可以做文件的上传／下载／修改／删除 以上三种服务器，只要 ip 地址能够访问，无论在任何位置，都能够使用！ 关于 WebDav 的权限问题 授权信息的格式 BASIC (用户名:口令)base64 安全性并不高，密码很容易被拦截和破解！ 应用场景：开发企业级的管理系统，可以用 WebDav 搭建一个内部的文件管理服务器，只是在公司内网使用！ Apache 配置： 1、Finder中，当前用户下(/Users/xxx(用户名)/Sites)，创建一个“Sites”文件夹； 1$ mkdir /Users/xxxx/Sites 2、修改配置文件的两个“路径”； 123# 切换目录$ cd /etc/apache2 123# 备份$ sudo cp httpd.conf httpd.conf.bak 123# 编辑$ sudo vi httpd.conf 123# 查找DocumentRoot$ : 修改路径为刚才新建文件夹路径(/Users/xxx(用户名)/Sites) 123# 查找“Options FollowSymLinks Multiviews”，添加一个单词“Indexes”$ : “Options Indexes FollowSymLinks Multiviews” 123# 查找php [ 视图模式下，通过“/php” 查找。]$ : 删除行首注释&quot;#&quot; 123# 保存并退出$ : x 3、切换目录，复制php.ini文件 123$ cd /etc$ sudo cp php.ini.default php.ini 4、重启apache服务器 1$ sudo apachectl -k restart 注意⚠： 每次需手动重启Apache服务器 1$ sudo apachectl -k start 执行脚本，显示拒绝访问（格式NTFS，修改权限） 123$ chmod 644 info.php &quot; (没有权限的文件名)$ chmod 644 *.* ［ 每日一句 ］ “ When in doubt, use brute force. “ – Ken Thompson ［ 每天一首英文歌 ］ “ Summertrain “ – Greyson Chance]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC * 夜间模式]]></title>
    <url>%2F2017%2F07%2F07%2FREVIEW%2F%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 DKNightVersion框架：实现夜间模式 GitHub：https://github.com/draveness/DKNightVersion.git 1、管理类的头文件 NightVersionManager.h 定义宏，通过RGB获取颜色！ 1#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] 定义头文件.h 12345678910111213141516typedef enum : NSUInteger &#123; DKThemeVersionNormal, DKThemeVersionNight,&#125; DKThemeVersion;extern NSString *const DKNightVersionNightFallingNotification;extern NSString *const DKNightVersionDawnComingNotification;extern CGFloat const DKNightVersionAnimationDuration;@interface DKNightVersionManager : NSObject+ (DKThemeVersion)currentThemeVersion;+ (void)nightFalling;+ (void)dawnComing;+ (BOOL)useDefaultNightColor;+ (void)setUseDefaultNightColor:(BOOL)use; 2、核心代码 NightVersionManager.m 2.1 单例、保证工具类对象，只被分配一次内存 123456789+ (DKNightVersionManager *)sharedNightVersionManager &#123; static dispatch_once_t once; static DKNightVersionManager *instance; dispatch_once(&amp;once, ^&#123; instance = [self new]; instance.useDefaultNightColor = YES; &#125;); return instance;&#125; * 2.2 设置主题的版本 1234567891011- (void)setThemeVersion:(DKThemeVersion)themeVersion &#123; if (_themeVersion == themeVersion) &#123; // if type does not change, don&apos;t execute code below to enhance performance. return; &#125; _themeVersion = themeVersion; [self changeColor:[[UIApplication sharedApplication].delegate.window.subviews firstObject]];&#125;``` * 2.3 改变颜色－－委托 - (void)changeColor:(id &lt;DKNightVersionSwichColorProtocol&gt;)object { if ([object respondsToSelector:@selector(changeColor)]) { [object changeColor]; } if ([object respondsToSelector:@selector(subviews)]) { if (![object subviews]) { // Basic case, do nothing. return; } else { for (id subview in [object subviews]) { // recursice darken all the subviews of current view. [self changeColor:subview]; if ([subview respondsToSelector:@selector(changeColor)]) { [subview changeColor]; } } } } } 12* 2.4 设置模式的颜色 + (BOOL)useDefaultNightColor { return self.sharedNightVersionManager.useDefaultNightColor; } + (void)setUseDefaultNightColor:(BOOL)use { [self.sharedNightVersionManager setUseDefaultNightColor:use]; } 1234* 3、控件分类（UIButton、UILabel、UIScrollView等） * 3.1 UIButton+NightVersion.m - (void)changeColor { [UIView animateWithDuration:DKNightVersionAnimationDuration animations:^{ [self setTitleColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightTitleColor : self.normalTitleColor forState:UIControlStateNormal]; [self setBackgroundColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightBackgroundColor : self.normalBackgroundColor]; [self setTintColor:([DKNightVersionManager currentThemeVersion] == DKThemeVersionNight) ? self.nightTintColor : self.normalTintColor]; }]; } 12* 3.2 UIButton+TitleColor.m // 加载时GCD，保证线程安全。 // runtime运行时，SEL &amp; Method的使用。 + (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(setTitleColor:forState:); SEL swizzledSelector = @selector(hook_setTitleColor:forState:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod){ class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } 12* 设置默认的标题颜色 (UIColor *)defaultNightTitleColor { if ([self isMemberOfClass:[UIButton class]]) { return UIColorFromRGB(0x5F80AC); } else { UIColor *resultColor = self.normalTitleColor ?: [UIColor clearColor]; return resultColor; }} 1234* 4、Test测试 * 4.1 AppDelegate.m (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.window.backgroundColor = [UIColor whiteColor]; [self.window makeKeyAndVisible]; UINavigationController *navigation = [[UINavigationController alloc] initWithRootViewController:[[RootViewController alloc] init]]; self.window.rootViewController = navigation; return YES;} 12* 4.2 RootViewController.m (void)nightFalls { [DKNightVersionManager nightFalling];} (void)dawnComes { [DKNightVersionManager dawnComing];} (void)push { [self.navigationController pushViewController:[[SuccViewController alloc] init] animated:YES];} 12* 4.3 SuccViewController.m (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.view.nightBackgroundColor = [UIColor colorWithRed:0.141 green:0.145 blue:0.153 alpha:1.0];}` ［ 每日一句 ］ “ Smiling is the best reaction in all situations. “ ［ 推荐网站 ］ http://www.umeng.com]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法]]></title>
    <url>%2F2017%2F07%2F04%2FREVIEW%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、A 搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A搜索算法是最佳优先搜索的范例。 2、集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。 3、二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。 4、分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。 5、Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。 6、数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。 7、Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。 8、Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。 9、离散微分算法（Discrete differentiation） 10、动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法 11、欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。 12、期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。 13、快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。 14、梯度下降（Gradient descent）——一种数学上的最优化算法。 15、哈希算法（Hashing） 16、堆排序（Heaps） 17、Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。 18、LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。 19、最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。 20、合并排序（Merge Sort） 21、牛顿法（Newton’s method）——求非线性方程（组）零点的一种重要的迭代法。 22、Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。 23、两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。 24、RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。 25、RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。 26、Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。 27、单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。 28、奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。 29、求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。 30、Strukturtensor算法——应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。 31、合并查找算法（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作： 查找：判断某特定元素属于哪个组。 合并：联合或合并两个组为一个组。 32、维特比算法（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡算法、编译、预处理]]></title>
    <url>%2F2016%2F06%2F14%2FREVIEW%2F%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[［ Bubble Sort ］ 简述： 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。冒泡排序的最坏时间复杂度为 O(n*n) 原理如下：（从后往前） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************* &gt; File Name: bubble.c &gt; Author: SpongeBob_Han (Bing Ma) &gt; Mail: 1605319671@qq.com &gt; Created Time: Sat Apr 18 16:27:34 2015************************************************************************//* blcok的使用 &amp; 调用系统清屏“clear” */#include&lt;stdio.h&gt;//#define swap(a, b) &#123; \int temp; temp = a; a = b; b = temp;\&#125;//#define MAX(x,y) (x)&gt;(y)?(x):(y)#pragma - 利用block打印出结果！void (^print)(int *, int) = ^(int a[], int n)&#123; int index; for(index = 0; index &lt; n; index++) printf(&quot;%d \t&quot;, a[index]);&#125;; #pragma - 引入终端命令“clear”等！int system(const char *string);void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125; Buble Sort 核心算法： 123456789101112131415161718#pragma - Bubble Sort !void bubble(int a[], int n)&#123; int i, j; for (i = 0; i &lt; n-1; ++i) for (j = n-1; j &gt; i; --j) if (a[j-1] &gt; a[j]) swap(&amp;a[j-1], &amp;a[j]); // print(a, n);&#125; 123456789101112131415161718192021// main.cint main()&#123; // 调用系统clear system(&quot;clear&quot;); printf(&quot;Bubble sort! \n\n&quot;); int a[] = &#123;7, 3, 66, 3, -5, 22, 77, 2&#125;; // 调用函数bubble bubble(a, 8); print(a, 8); printf(&quot;\n\n&quot;); return 0;&#125; 总结： 1、冒泡排序效率非常低 2、如果数组中包含n个元素，那么比较次数的复杂度：n * n 3、使用“归并”排序，高效率，复杂度：n log n ［ 每日一句 ］ “不要把期望放到别人那，你要知道，你未来要去哪儿？” ［ 每天一首英文歌 ］ “ When You’re Gone “ - Avril Lavigne]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppleScript]]></title>
    <url>%2F2016%2F06%2F08%2FREVIEW%2FAppleScript%2F</url>
    <content type="text"><![CDATA[定义：苹果公司开发的一种脚本语言，可以用来控制运行于Mac OS上的程序，也可以写成独立运行的Applet。 用处：可用于操控其他软件。 脚本例子： 12345tell application &quot;Finder&quot;get name of every diskend tell ==&gt; Result: 1&#123;&quot;Mac_SSD&quot;, &quot;Win8.1&quot;, &quot;home&quot;, &quot;net&quot;&#125; 2. 1234567891011tell application &quot;Finder&quot;set L to get every diskmy getNameof(1)end tellon getNameof(what)global Llocal sset s to get name of item what of Lreturn send getNameof ==&gt; Result: 1&quot;Mac_SSD&quot; 分享：AppleScript资料下载 |–&gt; Download ［ 每日一句 ］ “每个人，都有自己的一种活法。” ［ 每天一首英文歌 ］ “ Whistle “ - Flo Rida]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC * 单例、代理 & 通知]]></title>
    <url>%2F2016%2F05%2F14%2FREVIEW%2FOC_%E5%8D%95%E4%BE%8B_%E4%BB%A3%E7%90%86_%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[简介PS：手写单例、代理方法实现 &amp; 通知的简单使用！ [ 单例模式，代理设计模式，观察者模式！ ] 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 – GoF “四人帮”《Design Patterns: Elements of Reusable Object-Oriented Software》将设计模式提升到理论高度，并将之规范化。该书提出了23种基本设计模式。时至今日，在可复用面向对象软件的发展过程中，新的设计模式仍然不断出现。 1、单例－sharedXxx 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 123456789101112131415// 保证对象只被初始化一次+ (instancetype)sharedXxxxTools &#123; // GCD static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125; 12345678910111213141516171819//自定义单例，不用多线程：+(id)shareDefault&#123; static id s; if(s==nil) &#123; s=[[self alloc] init] &#125; return s;&#125;``` PS： 1、保证对象只被分配一次内存空间，通过dispatch_once能够保证单例的分配和初始化是线程安全的 (instancetype)allocWithZone:(struct _NSZone *)zone { // 同上 }122、当使用到 copy 时，调用。 // 如： NSMutableDictionary 的 key，会默认做一次 copy 操作 (id)copyWithZone:(NSZone *)zone { return instance; } 1234567891011121314151617 ---### 2、代理－delegate/protocol* 代理设计模式：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 * 模式结构：一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理类再访问真正要访问的对象。 a. 定义协议、方法 &amp; 属性 Person.h @class Person; @protocol PersonDelegate (void)personFightWithOthers:(Person *)person; @end @interface Person : NSObject @property (nonatomic, strong) id delegate; (void)fight; @end12b. 遵守协议，成为代理，实现方法 //Person.m (void)fight { if ([self.delegate respondsToSelector:@selector(personFightWithOthers:)]) { [self.delegate teacherFightWithOthers:self]; }}12 //Student.m @interface Student() @end (void)personFightWithOthers:(Person *)person { NSLog(@”fight…”);}12345678910111213141516171819202122232425262728293031---3、通知－Notification* Key-Value Coding (KVC)：即是指 NSKeyValueCoding 一个非正式的 Protocol，提供一种机制来间接访问对象的属性 * Key-Value Observing (KVO) ：监听对象的属性值变化 它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。每次指定的被观察的对象的属性被修改后，KVO自动通知相应的观察者。 #### 观察者模式* 什么时候使用观察者模式？ * 当你需要将改变通知所有的对象时，而你又不知道这些对象的具体类型，此时就可以使用观察者模式。 改变发生在同一个对象中，并在别的地方需要将相关的状态进行更新。* iOS中观察者模式的实现方法 * 在iOS中观察者模式的实现有三种方法：Notification、KVO以及标准方法。 --- // 添加观察者 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChanged:) name:UITextFieldTextDidChangeNotification object:nil]; // 移除观察者 [[NSNotificationCenter defaultCenter] removeObserver:self]; // 发送监听 [[NSNotificationCenter defaultCenter] postNotificationName:UITextFieldTextDidChangeNotification object:@”—-!!!!” userInfo:@{@”username”: @”zhangsan”}]; 12本地通知： // 1.创建本地通知对象 UILocalNotification *note = [[UILocalNotification alloc] init]; // 注册通知时，指定需要传递的数据 note.userInfo = @{@”name”:@”mb”,@”age”:@”22”,@”phone”: @”1234567890”}; // 2.注册通知 UIApplication *app = [UIApplication sharedApplication]; // 将通知添加到scheduledLocalNotifications数组中 [app scheduleLocalNotification:note]; ` 分享 《 Design Patterns: Elements of Reusable Object-Oriented Software 》 Gof设计模式下载：|–&gt; Download ［ 每日一句 ］ “非淡泊无以明志，非宁静无以致远。” ［ 推荐网站 ］ https://segmentfault.com}]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN & Git （一）]]></title>
    <url>%2F2016%2F03%2F04%2FREVIEW%2FSVN_Git_1%2F</url>
    <content type="text"><![CDATA[（一）SVN的使用、CornerStone图形化管理工具！简介 SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。 svn服务器，2种运行方式：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择。 svn存储数据，2种：BDB(一种事务安全型表类型)和FSFS(一种不需要数据库的存储系统)。因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。 详见SVN。 利用Terminal终端！ 1.将服务器文件下载到本地 1234567# 切换工作目录$ cd 经理的工作目录# checkout服务器上的代码仓库$ svn co http://192.168.1.103/svn/xxx --username=manager --password=manager 提示：checkout(co)之后，命令行会记录用户名和密码，后续操作不用再另行指定 经理添加文件 svn 常用命令123456789# 查看本地代码库状态$ svn st错误提示：&quot;is not a working copy&quot;，必须在svn的工作目录下才能正确使用svn的命令# 查看svn日志$ svn log 1234567# 查看某一个文件的日志$ svn log filename# 查看某一个文件某个版本的日志$ svn log filename@1 创建文件 1234567# 切换到工作目录$ cd weibo# 创建文件$ touch main.c 1234567# 打开并编写文件内容$ open main.c * 将文件提交到服务器 1234567# 查看工作目录状态$ svn st# 将文件添加到本地版本库中$ svn add main.c 123# 将文件提交到服务器的版本库中$ svn ci -m &quot;添加了main.c文件&quot; “小结” - 添加文件的两个步骤 1&gt; 将新建的文件添加到本地代码库 1$ svn add main.c 2&gt; 将刚刚添加的文件提交到服务器 1$ svn ci -m &quot;备注信息&quot; 注意：一定要养成写注释的良好习惯 团队成员加入 1&gt; 张三 1$ svn co http://10.0.1.15/svn/weibo --username=zhangsan --password=zhangsan 2&gt; 李四 1$ svn co http://10.0.1.15/svn/weibo --username=lisi --password=lisi “小结” 至此，一个项目的搭建工作就告一段落了 1&gt; 项目准备工作，通常由项目经理完成 2&gt; 程序员只需要把项目 co 到本地即可 提示：新入职一家公司后，别忘记让经理分配 svn 的账号和密码 张三添加文件 12345678910111213# 添加文件 Person.h Person.m$ touch Person.h Person.m# 修改 Person.h Person.m$ open Person.h$ open Person.m# 将 Person.h Person.m 添加到本地代码库$ svn add Person.* 123# 将内容提交到服务器$ svn ci -m &quot;添加了Person类&quot; 删除文件 12345678910111213141516# 删除文件$ svn rm Person.h# 提交删除$ svn ci -m &quot;删除了文件&quot;``` 注意：不要使用文件管理器直接删除文件 * 06. 撤销修改--- $ svn revert Person.m123 * 07. 恢复到之前的某个版本 $ svn update -r 5 $ svn up12 * 08. 冲突解决 (p) postpone 对比 (mc) mine-conflict 使用我的 (tc) theirs-conflict 使用对方的123456789101112131415161718192021222324 ---### 图形界面 * 1.安装CornerStone 下载最新版本，安装。 * 2.具体操作 * 1&gt; 添加远程代码仓库 * 2&gt; 导出代码库到本地 * 3&gt; 在本地目录下使用Xcode新建项目 注意：不要勾选 git，两套源代码管理同时存在会发生冲突 * 4&gt; 提交到代码仓库 * 5&gt; 其他用户操作* 3.忽略一些不需要上传的文件 .ignore` 4.SVN演练 1&gt; 修改viewcontroller,提交 2&gt; 添加Person类,提交 3&gt; 代码冲突演示 4&gt; storyboard冲突演示 5&gt; 利用storyboard查看历史版本,回退 6&gt; 利用xcode checkout 项目 5.目录规范 1&gt; Trunk 目前项目正在开发的版本 通常进入公司之后在该目录下开发 2&gt; Tags 存放已经上线的重大版本 3&gt; Branches 当发生重大bug或者有新需求时]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN & Git （二）]]></title>
    <url>%2F2016%2F03%2F04%2FREVIEW%2FSVN_Git_2%2F</url>
    <content type="text"><![CDATA[Git： 一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 是用于 Linux内核开发的版本控制工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使源代码的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。 利用Terminal终端！ Git 配置 利用SSH配置Git 123456789101112131415161718192021222324252627282930SSH1、创建SSH：$ ssh-keygen -t rsa -C “xxxx@xxx.com&quot; 2、将公钥添加到剪贴板，再添加(粘贴)到网页中$ pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard3、本地验证：$ eval &quot;$(ssh-agent -s)&quot; $ ssh-add ~/.ssh/git_os_rsa $ ssh -T git@git.oschina.net 4、导入工程：$ git clone https://github.com/xxx/xxxxx 配置仓库 123$ git config --global user.name &quot;YOUR NAME&quot;$ git config --global user.email &quot;YOUR EMAIL ADDRESS&quot; 初始化仓库 12345git initgit add .git commit -m “ProjectName&quot; 自定义Git命令： 1$ git config alias.cf “commit -m&quot; 添加.gitignore 脚本命令： 12345678910111213141516171819202122echo -e &quot;# Xcode#build/*.pbxuser*.mode1v3*.mode2v3*.perspectivev3xcuserdata*.xccheckout*.moved-asideDerivedData*.hmap*.ipa*.xcuserstate# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control## Pods/&quot; &gt; .gitignore 将.gitignore添加到代码库 1$ git add .gitignore 自定义快捷键： 123# 进入目录$HOME/.bashrc 或 $HOME/.bash_profile 123456789# 编辑内容 alias ll=&quot;ls -l&quot;alias cls=“clear”alias gc=&quot;git clone&quot;export CLICOLOR=1 1、将GitHub中的默认邮箱，修改为用户邮箱。（不能使用它自己的默认邮箱） 2、在提交过程中，一定要忽略［User Data］&amp;［Shared Data］文件！ ［ 每日一句 ］ 逝去的东西，最好不见，最好不念。 ［ 每天一首英文歌 ］ “ This Love “ – Taylor Swift]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树/堆/栈]]></title>
    <url>%2F2015%2F10%2F27%2FREVIEW%2F%E4%BA%8C%E5%8F%89%E6%A0%91_%E5%A0%86_%E6%A0%88%2F</url>
    <content type="text"><![CDATA[简介数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 逻辑结构包括： 1.集合数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系； 2.线性结构数据结构中的元素存在一对一的相互关系； 3.树形结构数据结构中的元素存在一对多的相互关系； 4.图形结构数据结构中的元素存在多对多的相互关系。 链表：1、对于，数据结构、堆栈的简单总结。 2、链表的操作！ 1.&gt; 数据结构 2.&gt; 自引用结构 1234567struct list &#123; int data; struct list *next;&#125; a; 3.&gt; 线性链表 12345678910111213141516171819/* list.h: */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char DATA; /* will use char in examples. */struct linked_list &#123; DATA d; struct linked_list *next;&#125;;typedef struct linked_list ELEMENT;typedef ELEMENT *LINK; 4.&gt; 链表操作 123456789101112131415161718192021222324252627#include &quot;list.h&quot;#include &lt;stdlib.h&gt;LINK string_to_list(char s[])&#123; LINK head; if (s[0] == &apos;\0&apos;) /* base case. */ return NULL; else &#123; head = malloc(sizeof(ELEMENT)); head -&gt; d = s[0]; head -&gt; next = string_to_list(s+1); return head; &#125;&#125; a.插入（insert） 12345678910111213/* Inserting an element in a linked list. */void insert(LINK p1, LINK p2, LINK q)&#123; assert(p1 -&gt; next == p2); p1 -&gt; next = q; /* insert */ q -&gt; next = p2;&#125; 删除（delete） 123456789101112131415/* Recursive deletion of a list. */void delete_list(LINK head)&#123; if (head != NULL) &#123; delete_list(head -&gt; next); free(head); /* release storage */ &#125;&#125; 堆栈 堆栈（压入、弹出） 堆栈、是暂时存放数据和地址，通常用来保护断点和现场； 堆，队列优先,先进先出(First-In/First-Out)； 栈，先进后出(First-In/Last-Out)。 ADT Stack（堆栈） 只能在一端(称为栈顶(top))对数据项进行插入和删除 push（压入＝＝增）、pop（弹出＝＝删）、top（取顶部元素＝＝查）、empty（判断是否为空）、full（判断是否已满）和reset（重置＝＝init） 堆栈的区别：一般栈区中的内存，系统会自己管理；作为程序员，我们只需管理堆区的内存分配&amp;释放！ 比喻： 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。 二叉树 简介： 树（tree）是一种称为节点（node）的元素的有限集合。 树具有一个唯一节点（根节点）,每个节点最多具有2个子节点（左孩子、右孩子）。 叶节点、它的左右孩子节点为NULL 遍历(Traversal) 是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问！ 树的遍历：1、沿链表移动；2、根据下标访问，指向链表的数组元素。 ［ 通过根节点访问时间决定 ］ 创建BTREE123456789101112131415161718192021222324252627/* Creating a binary tree. */ BTREE new_node(void) &#123; return (malloc(sizeof(NODE))); &#125; BTREE init_node (DATA d1, BTREE p1, BTREE p2) &#123; BTREE t; t = new_node(); t -&gt; d = d1; t -&gt; left = p1; t -&gt; right = p2; return t; &#125; 中序（inorder）： 先访问左子树，再访问根节点 左－&gt;根－&gt;右（必须递归遍历完后，再进行下一步） 12345678910111213141516171819202122232425262728 // Binary Tree /* Inorder binary tree traversal. */ void inorder (BTREE root) &#123; if (root != NULL) &#123; inorder(root -&gt; left); /* recur left */ printf(&quot;%c&quot;, root -&gt; d); inorder(root -&gt; right); /* recur right */ &#125; &#125; /* Output: A B C D E F G H I J */ ``` #### 前序（preorder）： * 先访问根节点 * **根－&gt;左－&gt;右** // [ preorder ] / Preorder and postorder binary tree traversal. / void preorder (BTREE root) { if (root != NULL) { printf(&quot;%c&quot;, root -&gt; d); preorder(root -&gt; left); /* recur left */ preorder(root -&gt; right); /* recur right */ } } / Output: G D B A C F E I H J / 12345#### 后序（postorder）：* 访问完左右子树后，才访问根节点* **左－&gt;右－&gt;根** // [ postorder ] void postorder (BTREE root) { if (root != NULL) { postorder(root -&gt; left); /* recur left */ postorder(root -&gt; right); /* recur right */ printf(&quot;%c&quot;, root -&gt; d); } } / Output: A C B E F D H J I G / ` 总结 1 抽象数据类型（ADT）堆栈可以使用链表来实现，对它的限制在它的第一个元素（称为顶部）。堆栈具有后进先出（LIFO）的特性，这个行为是由push()和pop()函数实现。 2 ADT队列也可以用链表来实现，对它的访问限制在它的头部和尾部。队列具有先进先出（FIFO）的特性，这个行为是由enqueue()和dequeue()函数实现的。 3 当算法使用迭代方式实现时，需要使用一个迭代循环，在监测到NULL时终止。迭代算法的代价是需要使用辅助指针，但它的效率一般高于递归算法。 4 链表处理的标准算法用递归来实现非常自然。基本条件常常就是检测到NULL链。一般条件通过在链表结构中移动链来进行递归。 5 二叉树由包含两个链成员的结构来表示，它组合了线性链表的动态特征，并且可以非常快地访问树中的每个元素。二叉树的元素之间的距离通常是对数级的。 6 二叉树最常用使用三种遍历方法。每种访问方法是通过根节点的访问时间决定的。这三种遍历方式都可以用递归来实现，从左向右链接每棵子树。 7 PS：自引用结构使用指针来访问相同类型结构的地址！！最简单的自引用结构是线性链表。每个元素指向它的下一个元素，最后一个元素指向NULL。 8 malloc()函数用于动态内存分配。free()函数用于释放参数所指向的内存，把它返回给系统，供以后使用。 9 我们可以指定同时涉及链表和数组的具有可怕复杂性的数据结构。其中一个例子就是实现普通树。在普通树中，每个节点可以具有任意数量的孩子。节点的孩子由链表来表示，它由一个头元素数组所指向。 ［ 每日一句 ］ “Nowadays, I don’t really know where I’m going, but I hope I go far. ” ［ 每天一首英文歌 ］ “ This Love “ - Taylor Swift]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC使用小技巧（二）]]></title>
    <url>%2F2015%2F10%2F21%2FREVIEW%2FMac_Tips_2%2F</url>
    <content type="text"><![CDATA[一、利用U盘制作，MAC的系统安装盘！ 1、准备工作： 1234准备一个 8GB 或以上容量的 U盘，确保里面的数据已经妥善备份好（该过程会抹掉 U 盘全部数据）从这里下载苹果官方 OS X Yosemite 正式版的安装程序 (可选 AppSotre 或网盘下载)如果你是从 Mac AppStore 下载的，下载完成后安装程序可能自动开始，这时先退出安装如从网盘下载的，请将解压后获得的 &quot;Install OS X Yosemite.app&quot; (显示为 &quot;安装 OS X Yosemite.app&quot;) 移动到「应用程序」文件夹里面 2、格式化 U 盘： 1插入你的 U盘，然后在「应用程序」-&gt;「实用工具」里面找到并打开「磁盘工具」，或者直接用 Spotlight 搜索“磁盘工具” 打开，如下图。 1234561 - 在左方列表中找到 U 盘的名称并点击 右边顶部选择 2 -「分区」3 -「分区布局」选择「1个分区」 （在导航栏中）4 -「名称」输入「iPlaySoft」 (由于后面的命令中会用到此名称，如果你要修改成其他(英文文)，请务必对应修改后面的命令) 在「格式」中选择 （在分区信息中的 ）5 -「Mac OS 扩展 (日志式)」这时，先别急着点“应用”，还要先在 6 -「选项」里面，如下图 12选择「GUID 分区表」，然后点击「好」最后再点「应用」开始对 U 盘进行格式化。 3、输入终端命令开始制作启动盘： 12345请再次确保名为 “安装 OS X Yosemite” 的文件是保存在「应用程序」的目录中在「应用程序」-&gt;「实用工具」里面找到「终端」并打开。也可以直接通过 Spotlight 搜索「终端」打开复制下面的命令，并粘贴到「终端」里，按回车运行：sudo /Applications/Install\ OS\ X\ Yosemite.app/Contents/Resources/createinstallmedia --volume /Volumes/iPlaySoft --applicationpath /Applications/Install\ OS\ X\ Yosemite.app --nointeraction回车后，系统会提示你输入管理员密码，接下来就是等待系统开始制作启动盘了。这时，命令执行中你会陆续看到类似以下的信息： 12345678Erasing Disk: 0%... 10%... 20%... 30%...100%...Copying installer files to disk...Copy complete.Making disk bootable...Copying boot files...Copy complete.Done.当出现 「Copy complete」和「Done」 启动盘已经制作完成了！ 4、U 盘启动安装 OS X Yosemite 的方法： 在目标电脑上插上 U 盘，然后重启你的 MAC，然后一直按住「option」(alt) 按键不放，直到屏幕显示多出一个 USB 启动盘的选项。【“command + R” – 进入系统设置界面，类似于windows系统下得“面板设置”界面】 二、Safari设置 –原因：DNS被拦截，被恶意推送广告。 【 思路 】 修改hosts文件 123$ cd /etc$ sudo vi hosts Password: 进行修改–&gt; 1【 127.0.0.1 www.baidu.com 】 通过本地回环测试IP，将百度拦截掉… 重启Apache服务器 1$sudo apachetl -k start 打开浏览器，进入www.baidu.com发现结果为测试页面It works！ 1、可以重置路由器 2、修改DNS 增加：199.91.73.222 &amp; 178.79.131.110 三、Safari的广告拦截 ADBlock &amp; ABP 插件的使用]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC使用小技巧（一）]]></title>
    <url>%2F2015%2F09%2F24%2FREVIEW%2FMac_Tips_1%2F</url>
    <content type="text"><![CDATA[［ Mac OS X 终端命令开启功能 ］ 1.Lion下显示资源库 方法一： 1234567显示在“终端”中输入下面的命令：chflags nohidden ~/Library/隐藏在“终端”中输入下面的命令：chflags hidden ~/Library/ 方法二： 1打开Finder，菜单中选择前往按住option键就会显示资源库项(每次打开都需要重复操作一次)。 2.Finder显示隐藏文件 1234显示隐藏文件在“终端”中输入下面的命令：defaults write com.apple.finder AppleShowAllFiles -bool truekillall Finder 1234恢复隐藏文件在“终端”中输入下面的命令：defaults write com.apple.finder AppleShowAllFiles -bool falsekillall Finder 3.Xcode卸载 12345在“终端”中输入下面的命令：sudo /Library/uninstall-devtools –mode=all为实际安装的目录，默认情况下Xcode安装在/Developer目录下，即可执行sudo /Developer/Library/uninstall-devtools –mode=all 4.在Finder标题栏显示完整路径 123在“终端”中输入下面的命令：defaults write com.apple.finder _FXShowPosixPathInTitle -bool YESkillall Finder 5.去掉窗口截屏的阴影 12345对窗口进行截屏的时候(Command-Shift-4, 空格)，得到的图片周围会自动被加上一圈阴影。如果你不喜欢这个阴影的效果，可以把它关掉。在“终端”中输入下面的命令：defaults write com.apple.screencapture disable-shadow -bool truekillall SystemUIServer 6.强制Safari在新标签中打开网页 12345Safari是默认支持标签浏览的。但是，我们在页面上点击链接或者在其他应用程序中点击链接的时候，Safari往往是打开了一个新的窗口，导致页面上的Safari窗口过多，不好管理。通过下面这个小窍门，我们可以让Safari默认是在一个新标签中打开网页。在“终端”中输入下面的命令：defaults write com.apple.Safari TargetedClicksCreateTabs -bool true 7.改变截屏图片的保存位置 123456Mac OS提供了非常方便的截屏快捷键，可以让我们非常快速的对整个屏幕、部分屏幕或者应用程序窗口进行截屏。不过，这个截屏功能有一个不足之处，就是只能将截 屏图片保存到桌面。如果我们截取的图片特别多，就会让桌面显得特别凌乱。那有没有办法来修改截屏图片的默认保存位置呢？有。方法非常简单，只要在“终端” 中输入下面的命令就可以了。defaults write com.apple.screencapture location 存放位置killall SystemUIServer在输入命令的时候，将“存放位置”替换成真正的文件夹就可以了。例如，你希望存放到自己用户目录的Screenshots文件夹下，就输入defaults write com.apple.screencapture location ~/Screenshots ［ Automator 使用］一：设置Mac锁屏快捷键 （原因：）如果用户要离开电脑一段时间，可以选择直接把笔记本直接合上。但是这样原先在跑 的进程就会挂起或者结束，如果正在下载，那么下载就被暂停（有时还不能恢复），如果正在提供网络服务，那么因为网络断了，别人也连不上你的笔记本。锁屏可 以解决这个问题，在Windows下用Win+L快捷键就锁屏了，但Mac OS X下一直没有默认的快捷键。 （做法：）首先在Finder找到“钥匙串访 问”这个实用工具（具体位置是/Applications/Utilities/Keychain Access.app），然后在“偏好设置”里选择“在菜单栏中显示钥匙串状态”。这时我们发现系统菜单多了一个像锁一样的小图标，只要点击它，就能找到 锁屏。 （PS：上述的方法实现了锁屏，但还没能达到快捷键控制锁屏的目标。虽然如此，但它的效果给我们一个锁屏思路。首先，我们要求屏幕保护程序在恢复时必须输入密码，然后锁屏问题就变成启动屏幕保护程序的问题了。） Automator设置 1、找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。 2、要用快捷键启动屏幕保护程序，相对复杂一点。在“应用程序”里找到“Automator”。新建一个服务，在“操作”下的“实用工具”里找 到“启动屏幕保护程序”，并把此操作拖动到右边，并且选择“没有输入”和位于“任何应用程序”，然后把服务保存为自己定义的名字。 3、在“系统偏好设置”里找到“键盘”，然后为刚才定义的服务配置快捷键，我设成了Command+Control+L 二：Mac自定义快捷键(退出/隐藏应用程序)1、“应用程序”－－&gt;“Automator”:1. 新建一个&quot;服务&quot; 2. &quot;操作&quot;----&gt;“实用工具”----&gt;&quot;退出所有应用程序&quot;/&quot;隐藏所有应用程序&quot; 3. 并把此操作拖动到右边 4. 并且选择“没有输入”和位于“任何应用程序”，如下图所示。 5. 然后把服务保存为自己定义的名字。 2、“系统偏好设置”－－“键盘”然后为刚才定义的服务－配置快捷键，设成了Command＋alt/option＋Q/H－－(自定义)]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC * 常用宏定义]]></title>
    <url>%2F2015%2F09%2F23%2FREVIEW%2FOC_%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[基本： 1、判断是否为真机 or 模拟器［注：记得先判断是否为模拟器咯，否则会失败的哦］ 123456789#if TARGET_IPHONE_SIMULATOR//模拟器#define IS_IPHONE 0#elif TARGET_OS_IPHONE//真机#define IS_IPHONE 1#endif 2、屏幕宽高 12345678910111213141516171819202122232425262728293031#pragma mark - 自定义宏//考虑转屏的影响，按照实际屏幕方向（UIDeviceOrientation）的宽高#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)#define STATUSBAR_HEIGHT ([UIApplication sharedApplication].statusBarFrame.size.height)/* //不考虑转屏的影响，只取竖屏（UIDeviceOrientationPortrait）的宽高 #define SCREEN_WIDTH MIN([UIScreenmainScreen].bounds.size.width, [UIScreenmainScreen].bounds.size.height) #define SCREEN_HEIGHT MAX([UIScreenmainScreen].bounds.size.height, [UIScreenmainScreen].bounds.size.width) #define STATUSBAR_HEIGHT MIN([UIApplicationsharedApplication].statusBarFrame.size.width, [UIApplicationsharedApplication].statusBarFrame.size.height) */ // 应用的实际宽高，除去“状态栏”#define APPFRAME_WIDTH ([UIScreen mainScreen].applicationFrame.size.width)#define APPFRAME_HEIGHT ([UIScreen mainScreen].applicationFrame.size.height) 3、 判断设备是否是iPhone/iPad 123#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) 4、 随机色 12345#define MBRandomColor [UIColor colorWithRed:arc4random_uniform(255)/255.0 green:arc4random_uniform(255)/255.0 blue:arc4random_uniform(255)/255.0 alpha:1]// 快速创建颜色#define MBColor(r, g, b, a) [UIColor colorWithRed:(r/255.0) green:(g/255.0) blue:(b/255.0) alpha:a] 5、 自定义打印Log 12345678910111213#ifdef DEBUG#define MyLog(fmt, ...) NSLog((@&quot;MyLog:\n FUNC: %s |**| [Line %d] \n&quot; fmt),__func__, __LINE__, ##__VA_ARGS__)#define MBLog(fmt, ...) NSLog((@&quot;[Line %d] --&gt; &quot; fmt), __LINE__, ##__VA_ARGS__)#else#define MyLog(fmt, ...)#define MBLog(fmt, ...)#endif 6、 当前系统版本 1#define CURRENT_SYSTEM_VERSION ([[[UIDevice currentDevice] systemVersion] floatValue]) 常用define.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#ifndef MacroDefinition_h#define MacroDefinition_h //-------------------获取设备大小-------------------------//NavBar高度#define NavigationBar_HEIGHT 44 //获取屏幕 宽度、高度#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height) //-------------------获取设备大小------------------------- //-------------------打印日志-------------------------//DEBUG 模式下打印日志,当前行#ifdef DEBUG# define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);#else# define DLog(...)#endif //重写NSLog,Debug模式下打印日志和当前行数#if DEBUG#define NSLog(FORMAT, ...) fprintf(stderr,&quot;\nfunction:%s line:%d content:%s\n&quot;, __FUNCTION__, __LINE__, ［NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);#else#define NSLog(FORMAT, ...) nil#endif //DEBUG 模式下打印日志,当前行 并弹出一个警告#ifdef DEBUG# define ULog(fmt, ...) &#123; UIAlertView *alert = ［UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;%s\n [Line %d] &quot;, __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:fmt, ##__VA_ARGS__] delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; &#125;#else# define ULog(...)#endif #define ITTDEBUG#define ITTLOGLEVEL_INFO 10#define ITTLOGLEVEL_WARNING 3#define ITTLOGLEVEL_ERROR 1 #ifndef ITTMAXLOGLEVEL #ifdef DEBUG#define ITTMAXLOGLEVEL ITTLOGLEVEL_INFO#else#define ITTMAXLOGLEVEL ITTLOGLEVEL_ERROR#endif #endif // The general purpose logger. This ignores logging levels.#ifdef ITTDEBUG#define ITTDPRINT(xx, ...) NSLog(@&quot;%s(%d): &quot; xx, __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)#else#define ITTDPRINT(xx, ...) ((void)0)#endif //打印当前方法的名称#define ITTDPRINTMETHODNAME() ITTDPRINT(@&quot;%s&quot;, __PRETTY_FUNCTION__) // Log-level based logging macros.#if ITTLOGLEVEL_ERROR &lt;= ITTMAXLOGLEVEL#define ITTDERROR(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDERROR(xx, ...) ((void)0)#endif #if ITTLOGLEVEL_WARNING &lt;= ITTMAXLOGLEVEL#define ITTDWARNING(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDWARNING(xx, ...) ((void)0)#endif #if ITTLOGLEVEL_INFO &lt;= ITTMAXLOGLEVEL#define ITTDINFO(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDINFO(xx, ...) ((void)0)#endif #ifdef ITTDEBUG#define ITTDCONDITIONLOG(condition, xx, ...) &#123; if ((condition)) &#123; \ITTDPRINT(xx, ##__VA_ARGS__); \&#125; \&#125; ((void)0)#else#define ITTDCONDITIONLOG(condition, xx, ...) ((void)0)#endif #define ITTAssert(condition, ...) \do &#123; \if (!(condition)) &#123; \［NSAssertionHandler currentHandler] \handleFailureInFunction:[NSString stringWithUTF8String:__PRETTY_FUNCTION__] \file:[NSString stringWithUTF8String:__FILE__] \lineNumber:__LINE__ \description:__VA_ARGS__]; \&#125; \&#125; while(0) //---------------------打印日志-------------------------- //----------------------系统---------------------------- // 是否iPad#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)// 是否iPad#define someThing (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)? ipad: iphone //获取系统版本#define IOS_VERSION ［[UIDevice currentDevice] systemVersion] floatValue]#define CurrentSystemVersion ［UIDevice currentDevice] systemVersion] //获取当前语言#define CurrentLanguage (［NSLocale preferredLanguages] objectAtIndex:0]) //判断是否 Retina屏、设备是否%fhone 5、是否是iPad#define isRetina ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 960), ［UIScreen mainScreen] currentMode].size) : NO)#define iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), ［UIScreen mainScreen] currentMode].size) : NO)#define isPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) //判断设备的操做系统是不是ios7#define IOS7 (［[UIDevice currentDevice].systemVersion doubleValue] &gt;= 7.0] //判断当前设备是不是iphone5#define kScreenIphone5 ((［UIScreen mainScreen] bounds].size.height)&gt;=568) //获取当前屏幕的高度#define kMainScreenHeight ([UIScreen mainScreen].applicationFrame.size.height) //获取当前屏幕的宽度#define kMainScreenWidth ([UIScreen mainScreen].applicationFrame.size.width) //定义一个define函数#define TT_RELEASE_CF_SAFELY(__REF) &#123; if (nil != (__REF)) &#123; CFRelease(__REF); __REF = nil; &#125; &#125; //判断是真机还是模拟器#if TARGET_OS_IPHONE//iPhone Device#endif #if TARGET_IPHONE_SIMULATOR//iPhone Simulator#endif //检查系统版本#define SYSTEM_VERSION_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) (［[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending) //----------------------系统---------------------------- //----------------------内存---------------------------- //使用ARC和不使用ARC#if __has_feature(objc_arc)//compiling with ARC#else// compiling without ARC#endif #pragma mark - common functions#define RELEASE_SAFELY(__POINTER) &#123; [__POINTER release]; __POINTER = nil; &#125; //释放一个对象#define SAFE_DELETE(P) if(P) &#123; [P release], P = nil; &#125; #define SAFE_RELEASE(x) [x release];x=nil //----------------------内存---------------------------- //----------------------图片---------------------------- //读取本地图片#define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:［NSBundle mainBundle]pathForResource:file ofType:ext］ //定义UIImage对象#define IMAGE(A) [UIImage imageWithContentsOfFile:［NSBundle mainBundle] pathForResource:A ofType:nil］ //定义UIImage对象#define ImageNamed(_pointer) [UIImage imageNamed:[UIUtil imageName:_pointer］ //建议使用前两种宏定义,性能高于后者//----------------------图片---------------------------- //----------------------颜色类---------------------------// rgb颜色转换（16进制-&gt;10进制）#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0] //带有RGBA的颜色设置#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A] // 获取RGB颜色#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]#define RGB(r,g,b) RGBA(r,g,b,1.0f) //背景色#define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0] //清除背景色#define CLEARCOLOR [UIColor clearColor] #pragma mark - color functions#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]#define RGBACOLOR(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)] //----------------------颜色类-------------------------- //----------------------其他---------------------------- //方正黑体简体字体定义#define FONT(F) [UIFont fontWithName:@&quot;FZHTJW--GB1-0&quot; size:F] //定义一个API#define APIURL @&quot;http://xxxxx/&quot;//登录API#define APILogin [APIURL stringByAppendingString:@&quot;Login&quot;] //设置View的tag属性#define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG]//程序的本地化,引用国际化的文件#define MyLocal(x, ...) NSLocalizedString(x, nil) //G－C－D#define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)#define MAIN(block) dispatch_async(dispatch_get_main_queue(),block) //NSUserDefaults 实例化#define USER_DEFAULT [NSUserDefaults standardUserDefaults] //由角度获取弧度 有弧度获取角度#define degreesToRadian(x) (M_PI * (x) / 180.0)#define radianToDegrees(radian) (radian*180.0)/(M_PI) //单例化一个类#define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \\static classname *shared##classname = nil; \\+ (classname *)shared##classname \&#123; \@synchronized(self) \&#123; \if (shared##classname == nil) \&#123; \shared##classname = ［self alloc] init]; \&#125; \&#125; \\return shared##classname; \&#125; \\+ (id)allocWithZone:(NSZone *)zone \&#123; \@synchronized(self) \&#123; \if (shared##classname == nil) \&#123; \shared##classname = [super allocWithZone:zone]; \return shared##classname; \&#125; \&#125; \\return nil; \&#125; \\- (id)copyWithZone:(NSZone *)zone \&#123; \return self; \&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 字典]]></title>
    <url>%2F2015%2F07%2F17%2FREVIEW%2FSwift_%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[1import UIKit 字典: 存储一组无序数据OC: 12345678NSDictionary *dict = [NSDictionary dictionaryWithObject:@&quot;bing&quot; forKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict);NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];NSLog(@&quot;%@&quot;, dict);NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;bing&quot;, @&quot;age&quot;:@30&#125;;NSLog(@&quot;%@&quot;, dict); Swift: 1234567891011121314151617181920212223// key一定要是可以hash的(String, Int, Float, Double, Bool), value没有要求var dict0 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict0)var dict1:Dictionary = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict1)var dict2:Dictionary&lt;String,Any&gt; = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict2)var dict3:[String:Any] = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict3)var dict4:[String:Any] = Dictionary(dictionaryLiteral: (&quot;name&quot;, &quot;bing&quot;), (&quot;age&quot;, 30))println(dict4)//空字典:var dict01:Dictionary&lt;String,Any&gt; = [:]var dict02 = Dictionary&lt;String,Any&gt;()var dict03 = [String:Any]()//不可变数组:var dict:Dictionary&lt;String,Any&gt; = [:]//可变数组:let dict:Dictionary&lt;String,Any&gt; = [:] 字典操作OC: 123456789101112//1.获取NSDictionary *dict = @&#123;@&quot;name&quot;:@&quot;bing&quot;, @&quot;age&quot;:@30&#125;;NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]);//2.修改NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];dict[@&quot;name&quot;] = @&quot;iversion&quot;;NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];[dict setObject:@&quot;iversion&quot; forKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]); Swift: 1234567891011121314151617181920212223242526272829303132//1.获取var dict04 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]println(dict04[&quot;name&quot;]!)//2.修改var dict05 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict05[&quot;name&quot;] = &quot;iverson&quot;println(dict05[&quot;name&quot;]!)var dict06 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict06.updateValue(&quot;iverson&quot;, forKey: &quot;name&quot;)println(dict06[&quot;name&quot;]!)var dict08 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// updateValue返回一个可选类型, 如果字典中不存在需要更新的key, 那么返回nil, 如果存在返回原始值if let orignal = dict08.updateValue(&quot;iverson&quot;, forKey: &quot;name&quot;)&#123;println(dict08[&quot;name&quot;]!)println(orignal)&#125;var dict07 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// updateValue返回一个可选类型, 如果字典中不存在需要更新的key, 那么返回nil并且会将新的键值对添加到字典中if let orignal = dict07.updateValue(&quot;iverson&quot;, forKey: &quot;abc&quot;)&#123;println(dict07[&quot;abc&quot;]!)println(orignal)&#125;println(dict07) 添加字典 OC: 12345678NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];dict[@&quot;height&quot;] = @175;NSLog(@&quot;%@&quot;, dict);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;name&quot;, @&quot;bing&quot;, @&quot;age&quot;, @30, nil];[dict setObject:@175 forKey:@&quot;height&quot;];NSLog(@&quot;%@&quot;, dict); Swift: 123var dict09 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict09[&quot;height&quot;] = 175;println(dict09) ** 删除字典OC: 1234567NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict removeObjectForKey:@&quot;name&quot;];NSLog(@&quot;%@&quot;, dict);NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict removeAllObjects];NSLog(@&quot;%@&quot;, dict); Swift: 1234567891011121314151617var dict_1 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict_1.removeValueForKey(&quot;name&quot;)println(dict_1)var dict_2 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]// removeValueForKey返回一个可选类型, 如果字典中不存在需要删除的key, 那么返回nil并且不会执行任何操作, 如果存在则删除key对应的值, 并且返回被删除的值if let orignal = dict_2.removeValueForKey(&quot;names&quot;)&#123;println(dict_2)println(orignal)&#125;println(dict_2)var dict_3 = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]dict_3.removeAll(keepCapacity: true) 遍历字典OC: 12345678910111213141516NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;NSLog(@&quot;key = %@ value = %@&quot;, key, obj);&#125;];NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];NSArray *keys = [dict allKeys];for (NSString *key in keys) &#123;NSLog(@&quot;%@&quot;, key);&#125;NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@&quot;bing&quot;, @&quot;name&quot;, @30, @&quot;age&quot;, nil];NSArray *values = [dict allValues];for (NSString *value in values) &#123;NSLog(@&quot;%@&quot;, value);&#125; Swift: 1234567891011121314151617181920212223var dict_a = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for (key , value) in enumerate(dict_a)&#123;println(&quot;key = \(key) value = \(value)&quot;)&#125;var dict_b = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for key in dict_b.keys &#123;println(&quot;key = \(key)&quot;)&#125;var dict_c = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for value in dict_c.values&#123;println(&quot;value = \(value)&quot;)&#125;var dict_d = [&quot;name&quot;:&quot;bing&quot;, &quot;age&quot;:30]for (key , value) in dict_d&#123;println(&quot;key = \(key) value = \(value)&quot;)&#125;]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 数组]]></title>
    <url>%2F2015%2F07%2F14%2FREVIEW%2FSwift_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1import UIKit 数组: 存储一组有序的数据 OC: 有值数组: 123NSArray *arr0 = @[@1, @2, @3];NSArray *arr1 = [NSArray arrayWithObjects:@1, @2, @3, nil];NSLog(@&quot;%@&quot;, arr1); 空数组 123NSArray *arr2 = @[];NSArray *arr3 = [NSArray array];NSLog(@&quot;%@&quot;, arr3); 不可变数组:NSArray可变数组:NSMutableArray Swift: 1234567891011121314151617// 有值数组var arr0 = [1, 2, 3]var arr1: Array = [1, 2, 3]var arr2: Array&lt;Int* = [1, 2, 3]var arr3: [Int] = [1, 2, 3]//var arr4: Int[] = [1, 2, 3] 早期写法// 空数组var arr5 = []var arr6 = [Int]()var arr7 = Array&lt;Int* ()// 带初始值的数组var arr8 = Array(count: 5, repeatedValue: 1)println(arr8)// 不可变数组:var arr0 = []// 可变数组:let arr0 = [] 元素类型OC: 12NSArray *arr = @[@1, @&quot;lnj&quot;, @1.75];NSLog(@&quot;%@&quot;, arr); Swift: 12var arr_02 = [1, &quot;lnj&quot;, 1.75]println(arr_02) 如果想明确表示数组中存放的是不同类型的数据, 可以使用Any关键字, 表示数组中可以存放不同类型的数据 12var arr:Array&lt;Any* = [1, &quot;lnj&quot;, 1.75]println(arr) 数组操作 1.获取长度OC: 12NSArray *arr = @[@1, @2, @3];NSLog(@&quot;%tu&quot;, arr.count); Swift: 12var arr = [1, 2, 3]println(arr.count) 2.判断是否为空OC: 12NSArray *arr = @[];NSLog(@&quot;%d&quot;, arr.count != 0); Swift: 12var arr_01 = [1, 2, 3]println(arr_01.isEmpty) 3.检索OC: 12NSArray *arr = @[@1, @2, @3];NSLog(@&quot;%@&quot;, arr[0]); Swift: 12var arr = [1, 2, 3]println(arr[0]) 4.追加OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr addObject:@4];NSLog(@&quot;%@&quot;, arr); Swift: 12345678910var arr02 = [1, 2, 3]arr02.append(4);println(arr02)var arr03 = [1, 2, 3]arr03 += [4]// arr03 += 4 以前的版本可以这样写//arr03 += [5, 6, 7]arr03 += arr03[0...1] // 还可以自己搞自己println(arr03) 5.插入OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr insertObject:@4 atIndex:0];NSLog(@&quot;%@&quot;, arr); Swift: 123var arr = [1, 2, 3]arr.insert(4, atIndex: 0);println(arr) 6.更新OC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];arr[0] = @8;NSLog(@&quot;%@&quot;, arr); Swift: 1234567var arr01 = [1, 2, 3]arr01[0] = 8println(arr01)var arr0002 = [1, 2, 3]arr0002[0..&lt;2] = [8, 9]println(arr0002) 7.删除OC: 1234567891011NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeObject:@1];NSLog(@&quot;%@&quot;, arr);NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeLastObject];NSLog(@&quot;%@&quot;, arr);NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeAllObjects];NSLog(@&quot;%@&quot;, arr); Swift: 123456789101112var arr001 = [1, 2, 3]arr001.removeAtIndex(0)println(arr001)var arr002 = [1, 2, 3]arr002.removeLast()println(arr002)var arr003 = [1, 2, 3]arr003.removeAll(keepCapacity: false) //是否保持容量, 如果为true, 即便删除了容量依然存在, 容量是2的倍数println(arr003)println(arr003.capacity) 注意: 如果数组是一个不可变数组不能更新/插入和删除第一个版本的不可变数组是可以修改的 RangeOC: 123NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];[arr removeObjectsInRange:NSMakeRange(0, 2)];NSLog(@&quot;%@&quot;, arr); Swift: 123456789101112131415161718192021var arr_1 = [1, 2, 3]arr_1.removeRange(Range(start: 1, end: 2))println(arr_1)var arr_2 = [1, 2, 3]arr_2.removeRange(0...0)println(arr_2)// 其实Range就是半闭区间var range = 0...5//range = 99 // 通过报错可以推断出类型println(range) // 通过打印也可以推断出类型var range1:Range&lt;Int* = 0...5//var range2:Range&lt;String* ; // 必须遵守ForwardIndexType协议// start 起点 end 终点var range3:Range&lt;Int* = Range(start: 0, end: 5)var range4:Range&lt;Int* = 0..&lt;5println(range1)println(range3)println(range4) OC: 12345NSMutableArray *arr = [NSMutableArray arrayWithObjects:@1, @2, @3, nil];NSRange range = NSMakeRange(0, 2);// [arr replaceObjectsInRange:range withObjectsFromArray:@[@99, @88]];[arr replaceObjectsInRange:range withObjectsFromArray:@[@99, @88, @77, @66]];NSLog(@&quot;%@&quot;, arr); Swift: 12345678910111213//arr.replaceRange(Range(start: 0, end: 2), with: [99, 88, 77, 66])arr.replaceRange(1..&lt;2, with: [99, 88, 77, 66])println(arr)// 等价于上一行代码var arr_3 = [1, 2, 3]arr_3[Range(start: 0, end: 2)] = [8, 9]println(arr_3)// 等价于上一行代码var arr_4 = [1, 2, 3]//arr[0...1] = [99, 88]//arr[0...1] = [99, 88, 77, 66] 遍历OC: 12345678910111213141516// for循环NSArray *arr = @[@1, @2, @3];for (int i = 0; i &lt; arr.count; i++) &#123;NSLog(@&quot;%@&quot;, arr[i]);&#125;// for in循环for (NSNumber *number in arr) &#123;NSLog(@&quot;%@&quot;, number);&#125;// 迭代器NSArray *arr0 = @[@1, @2, @&quot;1&quot;];[arr0 enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;NSLog(@&quot;index = %tu element = %@&quot;, idx, obj);&#125;]; Swift: 12345678910111213141516171819202122232425262728293031// for循环var arr_a = [1, 2, 3]for var i = 0 ; i &lt; arr_a.count ; i++&#123;println(arr_a[i])&#125;// for in循环for number in arr_a&#123;println(number)&#125;for i in 0..&lt;arr_a.count&#123;println(arr_a[i])&#125;// 取出数组中某个区间范围的值var arr_b = [1, 2, 3]for number in arr_b[0..&lt;3]&#123;println(number)&#125;// 利用enumerate迭代var arr_c = [1, 2, 3]for (index , value) in enumerate(arr_c)&#123;println(&quot;index = \(index) value = \(value)&quot;)&#125;]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 异常处理]]></title>
    <url>%2F2015%2F07%2F09%2FREVIEW%2FSwift_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[面向轨道编程 - Swift 中的异常处理 问题在开发过程中，异常处理算是比较常见的问题了。 举一个比较常见的例子：用户修改注册的邮箱，大概分为以下几个步骤： 接收到一个用户的请求：我要修改邮箱地址 验证一下请求是否合法，将请求进行格式转化 更新以前的邮箱地址记录 给新的邮箱地址发送验证邮件 将结果返回给用户上面的步骤如果一切顺利，那代码肯定干净利落，但是人生不如意十有八九，上面的步骤很容易出现问题： 用户把邮箱地址填成了家庭地址 用户是个黑客，没登录就发送了更新请求 发送验证邮件的时候服务器爆炸了，发送邮件失败各种异常都会导致这次操作的失败。 方案一在传统的处理方案里，一般是遇到异常就往上抛： 这种方案想必大家都不陌生，比如下面这段代码： 1234567891011121314NSError *err = nil;CGFloat result = [MathTool divide:2.5 by:3.0 error:&amp;err];if (err) &#123; NSLog(@&quot;%@&quot;, err)&#125; else &#123; [MathTool doSomethingWithResult:result]&#125; 方案二而另一种方案，则是将错误的结果继续往后传，在最后统一处理： 这种方案有两个问题： 在发生异常的时候，如何把异常继续传给下面的函数？ 当整个流程结束的时候，一个函数如何输出多个结果？ 车轨 我们把方案二抽象出来，就像是一段车轨： 对于同一个输入，会有 Success 和 Failure 两种输出结果，对于 Success 的情况，我们希望它能继续走到后面的流程里，而对于 Failure 的情况，它怎么处理并不重要，我们希望它能避开后面的流程： 于是乎，两段车轨拼接的时候，便成了这样： 那么三段什么的自然也不在话下了。我们把下面那根 Failure 的线路扩展一下，便会看到两条平行的线路，这便是“双轨模型” (Two Track Model) ，这是用“面向轨道编程”思想解决异常处理的理论基础。 这就是 “面向轨道编程” 。一开始我觉得这概念应该只是来搞笑的，仔细想想似乎倒也是很贴切。将事件流当做两条平行的轨道，如果顺利则在上行轨道，继续传递给下个业务逻辑去处理，如果出现异常也不慌，直接扔到下行轨道，一直在下行轨道传递到终点，在最后统一处理。 这样处理使得整个流程变成了一条双进双出的流水线，有点像是 shell 里的 pipeline ，上一次的输出作为下一次的输入，十分顺畅。而且拼接起来也很方便，我们可以把三段拼接成一段暴露给其他对象使用： 实现接下来看看在 Swift 中如何应用这种思路处理异常。 首先我们需要两种类型的输出结果： 成功，返回某种类型的值 失败，返回一个 Error 对象或者失败的具体信息照着这个想法，我们可以定义一个 Result 枚举用做输出： 1234567enum Result&lt;T&gt; &#123; case Success(T) case Failure(String) &#125; 利用 Swift 的枚举特性，我们可以在成功的枚举值里关联一些返回值，然后在失败的情况下则带上失败的消息内容。不过 enum 目前还不支持泛型，我们可以在外面封装一个 Box 类来解决这个问题： 1234567891011121314151617final class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125; enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String)&#125; 再看下一开始我们举的那个例子，用这个枚举类重新写下就是这样的： 12345678910111213var result = divide(2.5, by:3)switch result &#123;case .Success(let value): doSomethingWithResult(value)case .Failure(let errString): println(errString)&#125; “看起来好像也没什么嘛，你不还是用了个大括号处理两种情况嘛！”（嫌弃脸 确实正如这位热情的朋友所说，写完这个例子我也没觉得有什么优点，难道我就是来搞笑的？ “并不。”（严肃脸 栗子 接下来我们举个栗子玩一玩。为了更好的观赏效果，请允许我使用浮夸的写法和粗暴的命名举这个栗子。 比如对于即将输入的数字 x ，我们希望输出 4 / (2 / x - 1) 的计算结果。这里会有两处出错的可能，一个是 (2 / x) 时 x 为 0 ，另一个就是 (2 / x - 1) 为 0 的情况。 先看下传统写法： 123456789101112131415161718192021222324252627282930313233let errorStr = &quot;输入错误，我很抱歉&quot;func cal(value: Float) &#123; if value == 0 &#123; println(errorStr) &#125; else &#123; let value1 = 2 / value let value2 = value1 - 1 if value2 == 0 &#123; println(errorStr) &#125; else &#123; let value3 = 4 / value2 println(value3) &#125; &#125;&#125;cal(2) // 输入错误，我很抱歉cal(1) // 4.0cal(0) // 输入错误，我很抱歉 那么用面向轨道的思想怎么去解决这个问题呢？ 大概是这个样子的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final class Box&lt;T&gt; &#123; let value: T init(value: T) &#123; self.value = value &#125;&#125; enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String)&#125;let errorStr = &quot;输入错误，我很抱歉&quot; func cal(value: Float) &#123; func cal1(value: Float) -&gt; Result&lt;Float&gt; &#123; if value == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(value: 2 / value)) &#125; &#125; func cal2(value: Result&lt;Float&gt;) -&gt; Result&lt;Float&gt; &#123; switch value &#123; case .Success(let v): return .Success(Box(value: v.value - 1)) case .Failure(let str): return .Failure(str) &#125; &#125; func cal3(value: Result&lt;Float&gt;) -&gt; Result&lt;Float&gt; &#123; switch value &#123; case .Success(let v): if v.value == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(value: 4 / v.value)) &#125; case .Failure(let str): return .Failure(str) &#125; &#125; let r = cal3(cal2(cal1(value))) switch r &#123; case .Success(let v): println(v.value) case .Failure(let s): println(s) &#125; &#125;cal(2) // 输入错误，我很抱歉cal(1) // 4.0cal(0) // 输入错误，我很抱歉 同学，放下手里的键盘，冷静下来，有话好好说。 反思 面向轨道之后，代码量翻了两倍多，而且似乎变得更难读了。浪费了大家这么多时间结果就带来这么个玩意儿，实在是对不起观众们热情的掌声。 仔细看下上面的代码， switch 的操作重复而多余，都在重复着把 Success 和 Failure 分开的逻辑，实际上每个函数只需要处理 Success 的情况。我们在 Result 中加入 funnel 提前处理掉 Failure 的情况： 12345678910111213141516171819202122enum Result&lt;T&gt; &#123; case Success(Box&lt;T&gt;) case Failure(String) func funnel&lt;U&gt;(f:T -&gt; Result&lt;U&gt;) -&gt; Result&lt;U&gt; &#123; switch self &#123; case Success(let value): return f(value.value) case Failure(let errString): return Result&lt;U&gt;.Failure(errString) &#125; &#125;&#125; funnel 帮我们把上次的结果进行分流，只将 Success 的轨道对接到了下个业务上，而将 Failure 引到了下一个 Failure 轨道上。 接下来再回到栗子里，此时我们已经不再需要传入 Result 值了，只需要传入 value 即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func cal(value: Float) &#123; func cal1(v: Float) -&gt; Result&lt;Float&gt; &#123; if v == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(2 / v)) &#125; &#125; func cal2(v: Float) -&gt; Result&lt;Float&gt; &#123; return .Success(Box(v - 1)) &#125; func cal3(v: Float) -&gt; Result&lt;Float&gt; &#123; if v == 0 &#123; return .Failure(errorStr) &#125; else &#123; return .Success(Box(4 / v)) &#125; &#125; let r = cal1(value).funnel(cal2).funnel(cal3) switch r &#123; case .Success(let v): println(v.value) case .Failure(let s): println(s) &#125;&#125; 看起来简洁了一些。我们可以通过 cal1(value).funnel(cal2).funnel(cal3) 这样的链式调用来获取计算结果。 “面向轨道”编程确实给我们提供了一个很有趣的思路。本文只是一个简单地讨论，进一步学习可以仔细阅读后面的参考文献。比如 ValueTransformation.swift 这个真实的完整案例，以及 antitypical/Result 这个封装完整的 Result 库。文中的实现方案只是一个比较简单的方法，和前两种实现略有差异。 面向铁轨，春暖花开。愿每段代码都走在 Happy Path 上，愿每个人都有个 Happy Ending 。 文章来源：http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 字符串]]></title>
    <url>%2F2015%2F07%2F09%2FREVIEW%2FSwift_%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[1import UIKit 字符:Swift和OC字符不一样, Swift是用双引号. Swift中的字符类型和OC中的也不一样, OC中的字符占一个字节,因为它只包含ASCII表中的字符, 而Swift中的字符除了可以存储ASCII表中的字符还可以存储unicode字符, 例如中文OC的字符是遵守ASCII标准的,Swift的字符是遵守unicode标准的, 所以可以存放时间上所有国家语言的字符(大部分) OC: 12char charValue = &apos;a&apos;;char charValue = &apos;李&apos;; // 错误 Swift: 1234var charValue: Character = &quot;a&quot;var charValue1:Character = &quot;李&quot; //正确// 注意: 双引号中只能放一个字符, 如下是错误写法// Swift: var charValue:Character = &quot;ab&quot; 字符串:字符是单个字符的集合, 字符串是多个字符的集合, 想要存放多个字符需要使用字符串. 1C: char *stringValue = “ab”; char stringArr = “ab”; 12OC: NSString *stringValue = “ab”; 12Swift: var stringValue = “ab” 12* C语言中的字符串是以\0结尾的, 例如: char *stringValue = “abc\0bcd”; printf(“%s”, stringValue); 123 打印结果为abc* OC语言中的字符串也是以\0结尾的, 例如: NSString *stringValue = @”abc\0bcd”; NSLog(@”%@”, stringValue); 123 打印结果为abc* Swift中的字符串和C语言/OC语言中的字符串是不一样的 var stringValue = “ab” var stringValue1 = “abc\0bcd” println(stringValue) 123456字符串常用方法:* 计算字符串长度 C: char *stringValue = “abc李”; printf(“%tu”, strlen(stringValue)); 123打印结果6, 字节数OC: NSString *stringValue = @”abc李”; NSLog(@”%tu”, stringValue.length); 123打印结果4, 以UTF16计算Swift: Swift中的字符串是完全兼容unicode标准的 var stringValue2 = “abc李” println(count(stringValue2)) // 打印结果4, 无论以什么编码, 都是计算元素的个数 12345* 字符串拼接 C: char str1[] = “abc”; char str2 = “bcd”; char str = strcat(str1, str2); 1OC: NSMutableString str1 = [NSMutableString stringWithString:@”abc”]; NSString str2 = @”bcd”; [str1 appendString:str2]; NSLog(@”%@”, str1); 1Swift: var str1 = “abc”; var str2 = “bcd”; var str12 = str1 + str2; 123* 字符串格式化 OC: NSInteger index = 1; NSString *str1 = [NSMutableString stringWithFormat:@”http://www.trybst.com/pic/%tu.png&quot;, index]; NSLog(@”%@”, str1); 12Swift: var index = 1 var str3 = “http://www.trybst.com/pic/\(index).png&quot; println(str3) 1234* 字符串比较 OC: NSString str1 = @”abc”; NSString str2 = @”abc”; if ([str1 isEqualToString:str2]) { NSLog(@&quot;相等&quot;); } else { NSLog(@&quot;不相等&quot;); } if ([str1 compare:str2] == NSOrderedSame) { NSLog(@&quot;相等&quot;); } else { NSLog(@&quot;不相等&quot;); } 12Swift:(== / != / &gt;= / &lt;=), 和C语言的strcmp一样是逐个比较 var str10 = “abc”; var str20 = “abc”; if str10 == str20 { println(&quot;相等&quot;); } else { println(&quot;不相等&quot;); } var str11 = “abd”; var str21 = “abc”; if str11 &gt;= str21 { println(&quot;大于等于&quot;); } else { println(&quot;不大于等于&quot;); } 1234* 判断是否为空 OC: NSString *str1 = @”abc”; if (str1.length == 0) { NSLog(@”没有值”); }else{ NSLog(@”有值”); } 12Swift: var str0 = “abc” if str0.isEmpty { println(&quot;没有值&quot;) } else { println(&quot;有值&quot;) } 1234* 判断前后缀 OC: NSString *str = @”http://www.trybst.com&quot;; if ([str hasPrefix:@”http”]) { NSLog(@”是url”); } if ([str hasSuffix:@”.com”]) { NSLog(@”是国际域名”); } 12Swift: var str00 = “http://www.trybst.com&quot; if str00.hasPrefix(“http”) { println(&quot;是url&quot;); } if str00.hasSuffix(“.com”) { println(&quot;是国际域名&quot;); } 1234* 获取扩展名 OC: NSString *str = @”abc.txt”; NSLog(@”%@”, [str pathExtension]); 12Swift: var str02 = “abc.txt”; println(str02.pathExtension) 1234* 大小写转换 OC: NSString *str = @”abc.txt”; NSLog(@”%@”, [str uppercaseString]); NSLog(@”%@”, [str lowercaseString]); 1Swift: var str01 = “abc.txt”; println(str01.uppercaseString) println(str01.lowercaseString) 1234* 数据类型转换 OC: NSString *str = @”250”; NSInteger number = [str integerValue]; NSLog(@”%tu”, number); 12Swift: var str000 = “250” // 如果str不能转换为整数, 那么可选类型返回nil // str = “250sb” // 注意不要在转换时候(.toInt()!)强制解包, 如果不能转换又强制解包会触发运行时错误 var number:Int? = str000.toInt() if number != nil { // 以前的版本println会自动拆包, 现在的不会 println(number!) } // 如果要将字符串转换为其它类型, 需要借助OC中的方法 str000 = “10.1” var d = (str000 as NSString).doubleValue `]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift * 函数]]></title>
    <url>%2F2015%2F07%2F08%2FREVIEW%2FSwift_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简介 Swift是Apple在WWDC2014所发布的一门编程语言，用来撰写OS X和iOS应用程序[1]。在设计Swift时．就有意和Objective-C共存，Objective-C是Apple操作系统在导入Swift前使用的编程语言 Swift是供iOS和OS X应用编程的新编程语言，基于C和Objective-C，而却没有C的一些兼容约束。Swift采用了安全的编程模式和添加现代的功能来使得编程更加简单、灵活和有趣。界面则基于广受人民群众爱戴的Cocoa和Cocoa Touch框架，展示了软件开发的新方向。 函数 func1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283println(&quot;[===内部和外部参数===]&quot;);// MARK: 内部和外部参数(加＃)func say(MyName name:String, MyAge age:Int) &#123; println(&quot;hello name=\&quot;\(name)\&quot; &quot;+&quot;\n\n&quot; + &quot; age=\&quot;\(age)\&quot;&quot;)&#125;//say(&quot;mb&quot;, 22)say(MyName: &quot;mb&quot;, MyAge: 22)// 带＃func say(#name:String, #age:Int) &#123; println(&quot;hello \(name) \(age)&quot;)&#125;say(name: &quot;mb&quot;, age: 27) // MARK: 交换 inout （取地址，交换）func swap(inout a: Int, inout b:Int)&#123; var temp = a; a = b; b = temp;&#125;var x = 10;var y = 20;println(&quot;交换前 a=\(x) b=\(y)&quot;);swap(&amp;x, &amp;y);println(&quot;交换后 a=\(x) b=\(y)&quot;);// 交换func swap1(var a:Int, var b:Int)&#123; var temp = a; a = b; b = temp;&#125;var x1 = 10;var y2 = 20;println(&quot;Before exchanging.&quot;+&quot;\n\n&quot;+&quot; a=\(x) b=\(y)&quot;);swap1(x1, y2);println(&quot;After exchanging.&quot;+&quot;\n\n&quot;+&quot; a=\(x) b=\(y)&quot;); // 函数 变参func add(arr:Array&lt;Int&gt;) -&gt; Int&#123; var sum : Int = 0; for i in arr &#123; sum += i; &#125; return sum;&#125;println(add([1, 2, 3])); func add(#a:Int, #arr:Int...) -&gt; Int &#123; var sum:Int = 0; for i in arr &#123; sum += i; &#125; return sum + a;&#125;//println(add(7, [1, 2, 3])); 分享： Swift苹果官方版：|–&gt; Download ［ 每日一句 ］ “ There’s always more to learn, and there are always better ways to do what you’ve done before. “ – Donald Ervin Knuth ［推荐网址］ http://www.cocoachina.com]]></content>
      <categories>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods & Alcatraz]]></title>
    <url>%2F2015%2F06%2F06%2FREVIEW%2FCocoaPods_Alcatraz%2F</url>
    <content type="text"><![CDATA[安装CocoaPods 当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。自动集成&amp;管理第三方框架，避免每次都手动集成！ CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。 添加源 1$ sudo gem sources -a http://ruby.taobao.org/ 删除源 1$ sudo gem sources -r https://rubygems.org/ 安装CocoaPods 1$ sudo gem install cocoapods 设置 1$ pod setup 测试 1$ pod —version 查看 1$ gem sources -l 不更新远程仓库 1$ pod update —no-repo-update 导入AFNetworking框架 搜索 123$ pod search AFNetworking$ vi Podfile #写入 安装 1$ pod install 升级 1$ pod update 安装Alcatraz管理Xcode插件［Package Manager］！ Alcatraz only supports Xcode 7. 具体见：https://www.jianshu.com/p/cd75a6e7edf0 远程安装Alcatraz 1$ curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh 查看gem源 1$ gem sources –l gem自身升级 1$ sudo gem update –system 查看版本 1$ gem --version 清除过期的gem 1$ sudo gem cleanup 安装包 1$ sudo gem install cocoapods 删除包 1$ gem uninstall cocoapods 更新包 1$ sudo gem update 列出本地安装的包 1234$ gem list``` * 创建Podfile文件，在其中添加 $ vi Podfile $ echo “pod ‘SDWebImage’, ‘~&gt; 3.7.2’” &gt; Podfile $ pod –version 123456780.36.3 (0.36版本，不支持中文) ---初始化，远程git仓库。 $ git init $ git add . $ git commit -m “ProjectName”`]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git@OSC & SSH配置]]></title>
    <url>%2F2015%2F06%2F01%2FREVIEW%2FGit_OSC_SSH%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[[ 导入外部Git仓库到中国源代码托管平台（Git@OSC）]免费代码托管 您可以通过SSH或者HTTP的方式提交和管理代码,也可以通过Web的方式在线阅读,编辑代码与Team@OSC的集成 代码托管与团队协作的一体化服务式管理平台,轻松管理源代码。 方案1： 从原始地址clone一份bare仓库 1$ git clone --bare https://github.com/hannb/test.git 在Git@OSC上创建一个项目（http://git.oschina.net/projects/new）,这里注意，不要勾选使用Readme初始化项目，不要选择项目的授权协议和.gitignore 文件，因为这些会导致项目有第一个提交。 记下新建项目后的地址，推荐使用http或者ssh方式皆可，大项目推荐ssh方式。 1$ cd test 1$ git push --mirror git@git.oschina.net:[username]/test.git 此命令执行完成后即完成导入，删除 test 文件夹即可。 方案2：此方案，手头已经有了项目的完成仓库，则无需再从第三方代码托管平台上clone下来。 到Git@OSC上创建项目，同样不要选择以上所说的三项。 命令行进入项目目录，git status 确保项目状态为： nothing to commit, working directory clean 如果状态不是这样，则需要通过提交、暂存等操作，使项目当前状态为clean。 添加Git@OSC的remote 1$ git remote add git-osc git@git.oschina.net:[username]/test.git 推送所有分支和tags 1$ git push git-osc --all 1$ git push git-osc --tags 以上两条命令执行完毕，即完成导入。 方案3：此方案针对导入已有的SVN仓库 同上，先新建项目，不要选择以上所说的三项 使用git-svn工具clone svn仓库，git-svn 已经是Git的默认组建，如果你安装的是较新版本的Git客户端的话，则不需要再单独下载这个组件 1$ git svn clone http://translate4j.googlecode.com/svn/trunk/ translate4j 同样，进入项目目录，添加remote 1$ git remote add git-osc git@git.oschina.net:[username]/test.git 同样，推送所有分支和标签 1$ git push git-osc --all 1$ git push git-osc --tags 以上两条命令执行完毕，即推送完成 配置SSHSSH 为 Secure Shell 的缩写，安全外壳协议：SSH 为建立在应用层和传输层基础上的安全协议。 （公钥 &amp; 私钥）利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 －－同样，在GitHub上实现过程一样。 1、创建SSH： 1$ ssh-keygen -t rsa -C “test@gmail.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/Trybst/.ssh/id_rsa): git_os_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in git_os_rsa. Your public key has been saved in git_os_rsa.pub. The key fingerprint is: 07:73:91:05:3e:1b:3b:d4:ea:ed:4d:55:50:ae:4a:f8 test@gmail.com The key&apos;s randomart image is: +--[ RSA 2048]----+ | .++oo..o*| | ..+. ...| | o = ... o.| | = = ...| | S * . . | | o o . | | E | | | | | +-----------------+ 2、将公钥添加到剪贴板，再添加(粘贴)到网页中 123$ pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 3、本地验证： 1$ eval &quot;$(ssh-agent -s)&quot; Agent pid 2815 1$ ssh-add ~/.ssh/git_os_rsa Enter passphrase for /Users/Belief/.ssh/git_os_rsa: Identity added: /Users/xxx/.ssh/git_os_rsa (/Users/xxx/.ssh/git_os_rsa) 1$ ssh -T git@git.oschina.net Welcome to Git@OSC, SpongeBob_Han! 4、导入工程： 1$ git clone https://github.com/hannb/test.git ［ 用 $ git clone 仓库HTTPS地址，将其导出到$ cd Desktop桌面！ ］]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook配置]]></title>
    <url>%2F2015%2F05%2F27%2FREVIEW%2FGitBook%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[GitBook 是一个通过 Git 和 Markdown 来撰写书籍的工具。 生成格式有：JSON、ePub、PDF、Website ！ Git 方式 GitBook 使用 Git 进行写作内容管理。 从用户的角度看，这样能够方便地进行多人协作（连程序源代码都能管好，书籍自然不在话下），还不用学习额外概念或用法 从设计实现的角度看，这样能够合理利用已有工具（不重复造轮）满足产品需求，甚至扩展性更好（Git 相关服务能够利用的太多了） Markdown GitBook 不只是利用了 Git，目前非常流行的 Markdown 也被运用其中。 使用 Markdown 最大的好处就是简单： 语法简单，并且能够形象地表达出意图（例如无序列表使用 * ，强调使用 ** ，一个 # 表示 H1、两个 # 表示 H2） 不干扰写作者：语法标记在视觉上对写作者的负面影响不大（不像 HTML 满屏的 &lt;&gt;） 总之，Markdown 就是能够让写作者更专注于内容创作。 不过 GitBook 不只是简单地使用 Markdown，使用 Markdown 编写的内容只是源格式，最终的目标格式可以为 PDF、ePub 等。 ［ 配置方式 ］ 1&gt; 下载并安装 npm node-v0.12.0.pkg http://nodejs.org/download/ 2&gt; 安装 gitbook 1$ sudo npm install gitbook -g 3&gt; 进入终端 cd 到新建的电子书目录 123$ touch SUMMARY.md$ gitbook init 4&gt; 下载并安装 gitbookEditor，gitbook 本地编辑器 https://github.com/GitbookIO/editor/releases 打开并选择刚刚 init 的目录即可编辑 5&gt; 本地预览 1$ gitbook serve 6&gt; 下载并安装 calibre，生成电子书使用 calibre-2.20.0 http://calibre-ebook.com/download_osx 1$ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 7&gt; 生成电子书 12345$ gitbook epub或者$ gitbook pdf 8&gt; .gitignore https://github.com/github/gitignore.git PS： ［ 每日一句 ］ 静，是一种气质，也是一种修养。 ［ 推荐一首英文歌 ］ “ Unforgivable Sinner “ - Lene MarLin]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令操作]]></title>
    <url>%2F2015%2F05%2F26%2FREVIEW%2FLinux%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[基本命令［ man 查看 ］－－万能命令 1、ls 列出文件 (-al) 2、cd 转换目录 3、mkdir 建立新目录 4、cp 拷贝文件 (-R) 5、rm 删除文件 (-rf) 6、mv 移动文件 7、nano 文本编辑 8、cat 查看文件 9、open 打开文件 10、touch 新建文件 11、chgrp 改变文件所属用户组 12、chown 改变文件所有者 13、chmod 改变权限 (777－［r：4］［w：2］［x：1］［－：0］) 14、grep 模糊 匹配 123$ chmod 777 a.c $ grep -i &quot;ErroR&quot; log.text$ 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 pwd 显示当前目录的路径名 pwd 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142(PID) 12$ ps -A | grep .app$ kill -9 30142 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 选择操作时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir | df| 显示文件系统的总空间和可用空间 | df| | w | 显示当前系统活动的总信息 | w | ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github + Hexo + Next]]></title>
    <url>%2F2015%2F05%2F21%2FREVIEW%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo + Github 搭建个人博客 ！ 前提准备： 有一个 Github 账号，没有的话去注册一个； 安装了 Node.js、NPM，并了解相关基础知识； 安装了 Git 客户端 建立远程仓库trybst.github.io 登录 Github 新建一个名为你的 用户名.github.io 的仓库，比如说，如果你的 Github 用户名是 test，那么你就新建 test.github.io 的仓库（必须是你的用户名，其它名称无效，不区分大小写），将来你的网站访问地址就是 https://test.github.io 了 一、Hexo简介： 官网：https://hexo.io Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1、首先根据官网的流程安装安装前提：Nodi.js、Git 1$ npm install -g hexo-cli 2、建站123$ hexo init test$ cd test$ npm install 3、写作1$ hexo new [layout] &lt;title&gt; 布局 路径 post source/_posts page source draft source/_drafts 4、测试123$ hexo clean$ hexo g$ hexo s 打开浏览器：http://localhost:4000 5、部署通过git部署到github： 安装 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改配置 12345deploy: type: git repo: https://github.com/Trybst/trybst.github.io.git branch: master message: test 3.提交到git 123$ hexo clean$ hexo g$ hexo d 二、域名配置：绑定域名（当Blog生成并上传完成后） 购买自己的域名（推荐阿里云） 获取自己博客的地址ping 博客地址 1$ ping test.github.io 域名解析（阿里云后台配置域名解析）[ xxx.xxx.xxx.xxx为博客的ip地址 ] 记录类型 主机记录 解析线路 记录值 … A @ 默认 xxx.xxx.xxx.xxx … CNAME www 默认 [YOUR NAME].github.io … 如果需要设置二级域名，则需要在主机记录中添加二级域名的地址，如设置二级域名为 blog。 添加（或修改）A 记录设置为 life （注：A 记录中原来的 @ 表示空的意思） 添加（或修改）CNAME 记录设置为 www.life 「如果是想要直接将个人技术blog和生活blog分开，需要新建仓库就要添加域名解析记录，否则直接修改即可，别忘记修改CNAME中的子域！」 记录类型 主机记录 解析线路 记录值 … A life 默认 xxx.xxx.xxx.xxx … CNAME www.life 默认 [YOUR NAME].github.io … 问题：每次$ hexo d后，都需要重新自定义域名？解决方案： 在source 目录添加一个新文件CNAME 1$ vi CNAME CNAME的内容：只列出裸域或子域 e.g., trybst.com or blog.trybst.com 注意：这个文件不需要任何后缀！（如果还有问题，看一下自己域名解析是不是有问题！） 1www.trybst.com 参考文档： using a custom domain with github pages troubleshooting custom domains # github repository setup errors The CNAME file isn’t properly formatted The CNAME filename must be uppercaseOnly the bare domain or subdomain should be listed, e.g., example.com or blog.example.com, not https://example.com. 三、hexo - Next 主题官方主题：https://hexo.io/themes/NexT主题：https://github.com/theme-next/hexo-theme-next 「以NexT主题为例」 基本操作： 下载远程库到本地themes文件目录下 12$ cd ~/test/$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next 修改博客根目录 _config.yml 中的 theme: landscape 改为 theme: next，然后重新执行 hexo g 来重新生成 其他操作： 文章置顶 右上角 + github 评论系统 Google Adsense广告集成 添加动态背景 头像旋转小动效果 聊天系统 加载进度条 文章头部 代码 注释 title 文章主标题 date 创建时间 top 置顶（默认可以设置为-1，其他的 &gt;1 排序） tags 文章的标签 categories 文章的分类（用 - 可设置多类别） e.g: 12345678910111213--- title: TESTdate: 2016-05-14top: -1 tags: - test1 - test2categories: - test1 - tset2 --- 文章置顶 修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 1234567891011121314151617181920212223242526272829&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; // 置顶排序算法（可优化） posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前 1234567891011---title: TESTdate: xxxx-xx-xx categories: TESTtags:- test1- test2top: 998--- 头像360度旋转修改\themes\next\source\css\_common\components\sidebar\sidebar-author.styl文件中.site-author-image函数替换为如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125; img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; /* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 添加动态背景 修改next/layout/_layout.swig在和&lt; /body&gt;之间添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改/next/_config.yml,添加代码： 123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: &quot;0,0,255&quot; # RGB values, use &apos;,&apos; to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines 如果感觉线条太多的话，修改_layout.swig中代码为： 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; color：线条颜色，默认’0,0,0’；分别为RGB值 opacity：透明度，默认0.5 count：线条总数，默认150 zIndex：背景的z-index属性，css属性用于控制所在层的位置，默认-1 Github 右上角 1.首先选择右上角显示的样式，在样式1列表 or 样式2列表中，复制一段你喜欢的样式源码 1&lt;a href=&quot;https://your-url&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 2.把上面复制的源码粘贴到\themes\next\layout\layout.swig文件的div class=”headband”下面即可。 注意：href指向的地址需要修改成想要设置的github地址（a href=”https://your-url&quot;）。 主题美化 * 点击图片放大 官网：https://github.com/theme-next/theme-next-fancybox3 fancybox框架（注意fancybox2与fancybox3不能同时安装） 移除fancybox2 1$ rm -rf themes/next/source/lib/fancybox 切换到next目录下，保证有layout, source, languages 和 其他文件（没有就先安装一下fancybox） 123 $ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test 将module安装到themes/next/source/lib/目录下 1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 将fancybox在配置_config.yml中打开 1fancybox: true 主题美化 * 显示当前浏览进度 打开 themes/next/_config.yml ,搜索关键字 back2top ,把 false 改为 true 123456back2top:enable: true# Back to top in sidebar.sidebar: true# Scroll percent label in b2t button.scrollpercent: true 主题美化 * 聊天室tidio（免费）、chatra（收费）、DaoVoice（方便） tidio（chatra同理） 在/themes/next/_config.yml中设置，搜索关键字 &amp; 修改 123456chat: enable: true # service: chatra service: tidio icon: comment # icon in Font Awesome 4, set false to disable icon text: Chat # button text, change it as you wish 123456# Tidio （直接注册，简单设置一下即可使用！）# See: https://www.tidiochat.com# Dashboard: https://www.tidiochat.com/panel/dashboardtidio: enable: true key: xxxxxxxxxxxxxxxxxx # 可以在这里看到: https://www.tidiochat.com/panel/settings/developer DaoVoice 部分免费+国内+可绑定微信 注册DaoVoice，点击注册 [ 快速接入DaoVoice ] 后台控制台 -&gt; 应用设置 -&gt; 安装到网站 -&gt; app_id 主题美化 * 顶部加载进度条 下载&amp;安装Progress module这个模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$ cd /theme/next$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace``` * 在`/themes/next/_config.yml`中设置&lt;br/&gt;官网：[https://theme-next.org](https://theme-next.org)* GitHub：[https://github.com/theme-next/hexo-theme-next](https://github.com/theme-next/hexo-theme-next) * 使用手册：[http://theme-next.iissnan.com](http://theme-next.iissnan.com)---#### 补充资料：A记录和CNAME记录的区别？* 什么是域名解析？**域名解析：** &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;「将域名申请后做的IP（Internet Protocol）地址的转换过程！」IP地址是网络上识别您站点的数字地址，为了简单好记，采用域名来代替IP地址标识站点地址。域名的解析工作由DNS（Domain Name System）服务器完成！* 什么是A记录？**A（Address）记录：** &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;「用来指定主机名（域名）对应的IP地址记录。」用户可以将该域名下的网站服务器指向到自己的web server上。同时可以设置您的二级域名！* 什么是CNAME记录？**CNAME记录：** &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;「别名记录！」允许您将多个名字映射到另外一个域名。通常用于提供www和MAIL服务的计算机。e.g.,有一台计算机名为“host.mydomain.com”（A记录）。它同时提供www和MAIL服务，未来便于用户访问服务。可以为该计算机设置两个别名（CNAME）：www和MAIL。这两个别名的全称“http://www.mydomain.com”和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。* 使用A记录 &amp; CNAME 进行域名解析的区别？**区别：** A：把一个域名解析到一个IP地址（Address，特制数字IP地址）。 CNAME：把域名解析到另外一个域名。 CNAME将几个主机名指向一个别名，其实跟指向IP地址一样，因为这个别名也做了一个A记录。但使用CNAME记录可以很方便的变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。* 使用A记录&amp;CNAME哪个好？域名解析CNAME记录A记录哪一种比较好？如果论对网站的影响，就没有多大区别。但是：CNAME有一个好处就是稳定，就好像一个IP与一个域名的区别。服务商从方便维护的角度，一般也建议用户使用CNAME记录绑定域名的。如果主机使用了双线IP，显然使用CNAME也要方便一些。A记录也有一些好处，例如可以在输入域名时不用输入WWW.来访问网站哦！从SEO优化角度来看，一些搜索引擎如alex或一些搜索查询工具网站等等则默认是自动去掉WWW.来辨别网站，CNAME记录是必须有如：WWW(别名)前缀的域名，有时候会遇到这样的麻烦，前缀去掉了默认网站无法访问。有人认为，在SEO优化网站的时候，由于搜索引擎找不到去掉WWW.的域名时，对网站权重也会有些影响。因为有些网民客户也是不喜欢多写三个W来访问网站的，网站无法访问有少量网民客户会放弃继续尝试加WWW.访问域名了，因此网站访问浏览量也会减少一些。也有人认为同一个域名加WWW.和不加WWW.访问网站也会使网站权重分散，这也是个问题。但是可以使用301跳转把不加WWW.跳转到加WWW.的域名，问题就解决了。---#### Google Ads 集成 [注册](https://www.google.com/adsense/start/#/?modal_active=none) - 需要科学上网毕竟是在Google旗下--以NexT主题为例：（其他可留言探讨）* 1. 新建`google_adsense.swig`模块，并将ads代码复制粘贴 `$ vi theme/next/layout/_custom/google_adsense.swig` (adsbygoogle = window.adsbygoogle || []).push({});1234* 将ads代码，在 `theme/next/layout/_custom/head.swig` 中也粘贴一份 * 如需要每片文章都可以看到，将模块在`theme/next/layout/post.swig`目录下，自己想要的位置导入即可: {\% include ‘_custom/google_adsense.swig’ \%}` DONE]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESUME]]></title>
    <url>%2F2015%2F05%2F20%2FRESUME%2F</url>
    <content type="text"><![CDATA[welcome to my space, please enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>OTHER</category>
      </categories>
  </entry>
</search>
